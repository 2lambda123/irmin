<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=utf-8" http-equiv="Content-Type">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="Start" href="index.html">
<link rel="next" href="Irmin_mem.html">
<link rel="Up" href="index.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="Irmin" rel="Chapter" href="Irmin.html">
<link title="Irmin_mem" rel="Chapter" href="Irmin_mem.html">
<link title="Irmin_fs" rel="Chapter" href="Irmin_fs.html">
<link title="Irmin_git" rel="Chapter" href="Irmin_git.html">
<link title="Irmin_http" rel="Chapter" href="Irmin_http.html">
<link title="Irmin_http_server" rel="Chapter" href="Irmin_http_server.html">
<link title="Irmin_unix" rel="Chapter" href="Irmin_unix.html"><link title="Preliminaries" rel="Section" href="#1_Preliminaries">
<link title="Stores" rel="Section" href="#1_Stores">
<link title="User-Defined Contents" rel="Section" href="#1_UserDefinedContents">
<link title="High-level Stores" rel="Section" href="#1_HighlevelStores">
<link title="Examples" rel="Section" href="#examples">
<link title="Helpers" rel="Section" href="#1_Helpers">
<link title="Backends" rel="Section" href="#backend">
<link title="Synchronization" rel="Subsection" href="#2_Synchronization">
<title>Irmin</title>
</head>
<body>
<div class="navbar">&nbsp;<a class="up" href="index.html" title="Index">Up</a>
&nbsp;<a class="post" href="Irmin_mem.html" title="Irmin_mem">Next</a>
</div>
<h1>Module <a href="type_Irmin.html">Irmin</a></h1>

<pre><span class="keyword">module</span> Irmin: <code class="code"><span class="keyword">sig</span></code> <a href="Irmin.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info module top">
Irmin public API.
<p>

    <code class="code"><span class="constructor">Irmin</span></code> is a library to design and use persistent stores with
    built-in snapshot, branching and reverting mechanisms. Irmin uses
    concepts similar to <a href="http://git-scm.com/">Git</a> but it exposes
    them as a high level library instead of a complex command-line
    frontend. It features a <em>bidirectional</em> Git backend, where an
    application can read and persist its state using the Git format,
    fully-compatible with the usual Git tools and workflows.
<p>

    Irmin is designed to use a large variety of backends. It is
    written in pure OCaml and does not depend on external C stubs; it
    is thus very portable and aims to run everywhere, from Linux to
    browser and MirageOS unikernels.
<p>

    Consult the <code class="code">basics</code> and <a href="Irmin.html#examples"><i>Examples</i></a> of use for a quick
    start. See also the <a href="Irmin_unix.html">documentation</a> for the unix
    backends.
<p>

    <em>Release 1.0.2 - %%HOMEPAGE%% </em><br>
</div>
<hr width="100%">

<pre><span id="VALversion"><span class="keyword">val</span> version</span> : <code class="type">string</code></pre><div class="info ">
The version of the library.<br>
</div>
<br>
<h1 id="1_Preliminaries">Preliminaries</h1><br>

<pre><span class="keyword">module</span> <a href="Irmin.Type.html">Type</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Irmin.Type.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Dynamic types for Irmin values.
</div>

<pre><span class="keyword">module</span> <a href="Irmin.Info.html">Info</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Irmin.Info.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Commit info are used to keep track of the origin of write
    operations in the stores.
</div>

<pre><span class="keyword">module</span> <a href="Irmin.Merge.html">Merge</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Irmin.Merge.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
<code class="code"><span class="constructor">Merge</span></code> provides functions to build custom 3-way merge operators
    for various user-defined contents.
</div>

<pre><span class="keyword">module</span> <a href="Irmin.Diff.html">Diff</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Irmin.Diff.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Differences between values.
</div>
<br>
<h1 id="1_Stores">Stores</h1><br>

<pre><span id="TYPEconfig"><span class="keyword">type</span> <code class="type"></code>config</span> </pre>
<div class="info ">
The type for backend-specific configuration values.
<p>

    Every backend has different configuration options, which are kept
    abstract to the user.<br>
</div>


<pre><span id="TYPEdiff"><span class="keyword">type</span> <code class="type">'a</code> diff</span> = <code class="type">'a <a href="Irmin.Diff.html#TYPEt">Diff.t</a></code> </pre>
<div class="info ">
The type for representing differences betwen values.<br>
</div>

<br>
An Irmin store is automatically built from a number of lower-level
    stores, implementing fewer operations, such as <a href="Irmin.AO.html">append-only</a>
    and <a href="Irmin.RW.html">read-write</a> stores. These low-level stores are provided
    by various backends.<br>

<pre><span class="keyword">module type</span> <a href="Irmin.RO.html">RO</a> = <code class="code"><span class="keyword">sig</span></code> <a href="Irmin.RO.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Read-only backend stores.
</div>

<pre><span class="keyword">module type</span> <a href="Irmin.AO.html">AO</a> = <code class="code"><span class="keyword">sig</span></code> <a href="Irmin.AO.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Append-only backend store.
</div>

<pre><span class="keyword">module type</span> <a href="Irmin.LINK.html">LINK</a> = <code class="code"><span class="keyword">sig</span></code> <a href="Irmin.LINK.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Immutable Link store.
</div>

<pre><span class="keyword">module type</span> <a href="Irmin.RW.html">RW</a> = <code class="code"><span class="keyword">sig</span></code> <a href="Irmin.RW.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Read-write stores.
</div>
<br>
<h1 id="1_UserDefinedContents">User-Defined Contents</h1><br>

<pre><span class="keyword">module</span> <a href="Irmin.Path.html">Path</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Irmin.Path.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Store paths.
</div>

<pre><span class="keyword">module</span> <a href="Irmin.Hash.html">Hash</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Irmin.Hash.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Hashing functions.
</div>

<pre><span class="keyword">module</span> <a href="Irmin.Contents.html">Contents</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Irmin.Contents.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
<code class="code"><span class="constructor">Contents</span></code> specifies how user-defined contents need to be <em>    serializable</em> and <em>mergeable</em>.
</div>

<pre><span class="keyword">module</span> <a href="Irmin.Branch.html">Branch</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Irmin.Branch.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
User-defined branches.
</div>

<pre><span class="keyword">module</span> <a href="Irmin.Metadata.html">Metadata</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Irmin.Metadata.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
<code class="code"><span class="constructor">Metadata</span></code> defines metadata that is attached to contents but stored in
    nodes.
</div>

<pre><span class="keyword">module</span> <a href="Irmin.Private.html">Private</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Irmin.Private.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
<code class="code"><span class="constructor">Private</span></code> defines functions only useful for creating new
    backends.
</div>
<br>
<h1 id="1_HighlevelStores">High-level Stores</h1>
<p>

    An Irmin store is a branch-consistent store where keys are lists
    of steps.
<p>

    An example is a Git repository where keys are filenames, <em>i.e.</em>
    list of <code class="code"><span class="string">'/'</span></code>-separated strings. More complex examples are
    structured values, where steps might contain first-class field
    accessors and array offsets.
<p>

    Irmin provides the following features:
<p>

    <ul>
<li>Support for fast clones, branches and merges, in a fashion very
       similar to Git.</li>
<li>Efficient taging areas for fast, transient, in-memory operations.</li>
<li>Fast <a href="Irmin.Sync.html">synchronization</a> primitives between remote
       stores, using native backend protocols (as the Git protocol)
       when available.</li>
</ul>
<br>

<pre><span class="keyword">module type</span> <a href="Irmin.S.html">S</a> = <code class="code"><span class="keyword">sig</span></code> <a href="Irmin.S.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Irmin stores.
</div>

<pre><span class="keyword">module type</span> <a href="Irmin.S_MAKER.html">S_MAKER</a> = <code class="code"><span class="keyword">functor</span>&nbsp;(</code><code class="code"><span class="constructor">M</span></code><code class="code">&nbsp;:&nbsp;</code><code class="type"><a href="Irmin.Metadata.S.html">Metadata.S</a></code><code class="code">)&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;</code><code class="code"><span class="keyword">functor</span>&nbsp;(</code><code class="code"><span class="constructor">C</span></code><code class="code">&nbsp;:&nbsp;</code><code class="type"><a href="Irmin.Contents.S.html">Contents.S</a></code><code class="code">)&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;</code><code class="code"><span class="keyword">functor</span>&nbsp;(</code><code class="code"><span class="constructor">P</span></code><code class="code">&nbsp;:&nbsp;</code><code class="type"><a href="Irmin.Path.S.html">Path.S</a></code><code class="code">)&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;</code><code class="code"><span class="keyword">functor</span>&nbsp;(</code><code class="code"><span class="constructor">B</span></code><code class="code">&nbsp;:&nbsp;</code><code class="type"><a href="Irmin.Branch.S.html">Branch.S</a></code><code class="code">)&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;</code><code class="code"><span class="keyword">functor</span>&nbsp;(</code><code class="code"><span class="constructor">H</span></code><code class="code">&nbsp;:&nbsp;</code><code class="type"><a href="Irmin.Hash.S.html">Hash.S</a></code><code class="code">)&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;</code><code class="type"><a href="Irmin.S.html">S</a></code><code class="type">  with type key = P.t
       and type step = P.step
       and type metadata = M.t
       and type contents = C.t
       and type branch = B.t
       and type Commit.Hash.t = H.t
       and type Tree.Hash.t = H.t
       and type Contents.Hash.t = H.t</code></pre><div class="info">
<code class="code"><span class="constructor">S_MAKER</span></code> is the signature exposed by any backend providing <a href="Irmin.S.html"><code class="code"><span class="constructor">Irmin</span>.<span class="constructor">S</span></code></a>
    implementations.
</div>

<pre><span class="keyword">module type</span> <a href="Irmin.KV.html">KV</a> = <code class="type"><a href="Irmin.S.html">S</a></code><code class="type">  with type key = string list
     and type step = string
     and type branch = string</code></pre><div class="info">
<code class="code"><span class="constructor">KV</span></code> is similar to <a href="Irmin.S.html"><code class="code"><span class="constructor">Irmin</span>.<span class="constructor">S</span></code></a> but choose sensible implementations for
    path and branch.
</div>

<pre><span class="keyword">module type</span> <a href="Irmin.KV_MAKER.html">KV_MAKER</a> = <code class="code"><span class="keyword">functor</span>&nbsp;(</code><code class="code"><span class="constructor">C</span></code><code class="code">&nbsp;:&nbsp;</code><code class="type"><a href="Irmin.Contents.S.html">Contents.S</a></code><code class="code">)&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;</code><code class="type"><a href="Irmin.KV.html">KV</a></code><code class="type">  with type contents = C.t</code></pre><div class="info">
<code class="code"><span class="constructor">KV_MAKER</span></code> is like <a href="Irmin.S_MAKER.html"><code class="code"><span class="constructor">Irmin</span>.<span class="constructor">S_MAKER</span></code></a> but where everything except the
    contents is replaced by sensible default implementations.
</div>
<br>
<h2 id="2_Synchronization">Synchronization</h2><br>

<pre><span id="TYPEremote"><span class="keyword">type</span> <code class="type"></code>remote</span> </pre>
<div class="info ">
The type for remote stores.<br>
</div>


<pre><span id="VALremote_uri"><span class="keyword">val</span> remote_uri</span> : <code class="type">string -> <a href="Irmin.html#TYPEremote">remote</a></code></pre><div class="info ">
<code class="code">remote_uri&nbsp;s</code> is the remote store located at <code class="code">uri</code>. Use the
    optimized native synchronization protocol when available for the
    given backend.<br>
</div>
<br>
<h1 id="examples">Examples</h1>
<p>

    These examples are in the <code class="code">examples</code> directory of the
    distribution.
<p>

    <h3 id="3_Synchronization">Synchronization</h3>
<p>

    A simple synchronization example, using the
    <a href="Irmin_unix.Git.html">Git</a> backend and the <a href="Irmin.Sync.html"><code class="code"><span class="constructor">Irmin</span>.<span class="constructor">Sync</span></code></a> helpers. The
    code clones a fresh repository if the repository does not exist
    locally, otherwise it performs a fetch: in this case, only
    the missing contents is downloaded.
<p>

<pre class="codepre"><code class="code"><span class="keyword">open</span> <span class="constructor">Lwt</span>.<span class="constructor">Infix</span>

<span class="keyword">module</span> <span class="constructor">S</span> = <span class="constructor">Irmin_unix</span>.<span class="constructor">Git</span>.<span class="constructor">FS</span>.<span class="constructor">KV</span>(<span class="constructor">Irmin</span>.<span class="constructor">Contents</span>.<span class="constructor">String</span>)
<span class="keyword">module</span> <span class="constructor">Sync</span> = <span class="constructor">Irmin</span>.<span class="constructor">Sync</span>(<span class="constructor">S</span>)
<span class="keyword">let</span> config = <span class="constructor">Irmin_git</span>.config ~root:<span class="string">"/tmp/test"</span> ()

<span class="keyword">let</span> upstream =
  <span class="keyword">if</span> <span class="constructor">Array</span>.length <span class="constructor">Sys</span>.argv = 2 <span class="keyword">then</span> (<span class="constructor">Irmin</span>.remote_uri <span class="constructor">Sys</span>.argv.(1))
  <span class="keyword">else</span> (<span class="constructor">Printf</span>.eprintf <span class="string">"Usage: sync [uri]\n%!"</span>; exit 1)

<span class="keyword">let</span> test () =
  <span class="constructor">S</span>.<span class="constructor">Repo</span>.v config &gt;&gt;= <span class="constructor">S</span>.master
  &gt;&gt;= <span class="keyword">fun</span> t  <span class="keywordsign">-&gt;</span> <span class="constructor">Sync</span>.pull_exn t upstream <span class="keywordsign">`</span><span class="constructor">Set</span>
  &gt;&gt;= <span class="keyword">fun</span> () <span class="keywordsign">-&gt;</span> <span class="constructor">S</span>.get t [<span class="string">"README.md"</span>]
  &gt;|= <span class="keyword">fun</span> r  <span class="keywordsign">-&gt;</span> <span class="constructor">Printf</span>.printf <span class="string">"%s\n%!"</span> r

<span class="keyword">let</span> () = <span class="constructor">Lwt_main</span>.run (test ())
</code></pre>
<p>

    <h3 id="3_Mergeablelogs">Mergeable logs</h3>
<p>

    We will demonstrate the use of custom merge operators by
    defining mergeable debug log files. We first define a log entry
    as a pair of a timestamp and a message, using the combinator
    exposed by <a href="https://github.com/mirage/mirage-tc">mirage-tc</a>:
<p>

<pre class="codepre"><code class="code">  <span class="keyword">module</span> <span class="constructor">Entry</span> = <span class="keyword">sig</span>
    <span class="keyword">include</span> <span class="constructor">Irmin</span>.<span class="constructor">Contents</span>.<span class="constructor">Conv</span>
    <span class="keyword">val</span> v: string <span class="keywordsign">-&gt;</span> t
    <span class="keyword">val</span> compare: t <span class="keywordsign">-&gt;</span> t <span class="keywordsign">-&gt;</span> int
    <span class="keyword">val</span> timestamp: t <span class="keywordsign">-&gt;</span> int
  <span class="keyword">end</span> = <span class="keyword">struct</span>

    <span class="keyword">type</span> t = { timestamp: int; message : string; }

    <span class="keyword">let</span> compare x y = compare x.timestamp y.timestamp

    <span class="keyword">let</span> v message =
      incr time;
      { timestamp = !time; message }

    <span class="keyword">let</span> t =
      <span class="keyword">let</span> <span class="keyword">open</span> <span class="constructor">Irmin</span>.<span class="constructor">Type</span> <span class="keyword">in</span>
      record <span class="string">"entry"</span> (<span class="keyword">fun</span> timestamp message <span class="keywordsign">-&gt;</span> { timestamp; message })
      |+ field <span class="string">"timestamp"</span> int    (<span class="keyword">fun</span> t <span class="keywordsign">-&gt;</span> t.timestamp)
      |+ field <span class="string">"message"</span>   string (<span class="keyword">fun</span> t <span class="keywordsign">-&gt;</span> t.message)
      |&gt; sealr

    <span class="keyword">let</span> timestamp t = t.timestamp

    <span class="keyword">let</span> pp ppf { timestamp; message } =
      <span class="constructor">Fmt</span>.pf ppf  <span class="string">"%04d: %s\n"</span> timestamp message

    <span class="keyword">let</span> of_string str =
      <span class="keyword">match</span> <span class="constructor">String</span>.cut ~sep:<span class="string">": "</span> str <span class="keyword">with</span>
      <span class="keywordsign">|</span> <span class="constructor">None</span> <span class="keywordsign">-&gt;</span> <span class="constructor">Error</span> (<span class="keywordsign">`</span><span class="constructor">Msg</span> (<span class="string">"invalid entry: "</span> ^ str))
      <span class="keywordsign">|</span> <span class="constructor">Some</span> (x, message) <span class="keywordsign">-&gt;</span>
        <span class="keyword">try</span> <span class="constructor">Ok</span> { timestamp = int_of_string x; message }
        <span class="keyword">with</span> <span class="constructor">Failure</span> e <span class="keywordsign">-&gt;</span> <span class="constructor">Error</span> (<span class="keywordsign">`</span><span class="constructor">Msg</span> e)
  <span class="keyword">end</span>
</code></pre>
<p>

    A log file is a list of entries (one per line), ordered by
    decreasing order of timestamps. The 3-way <code class="code">merge</code> operator for log
    files concatenates and sorts the new entries and prepend them
    to the common ancestor's ones.
<p>

<pre class="codepre"><code class="code"><span class="comment">(* A log file *)</span>
<span class="keyword">module</span> <span class="constructor">Log</span>: <span class="keyword">sig</span>
  <span class="keyword">include</span> <span class="constructor">Irmin</span>.<span class="constructor">Contents</span>.<span class="constructor">S</span>
  <span class="keyword">val</span> add: t <span class="keywordsign">-&gt;</span> <span class="constructor">Entry</span>.t <span class="keywordsign">-&gt;</span> t
  <span class="keyword">val</span> empty: t
<span class="keyword">end</span> = <span class="keyword">struct</span>

  <span class="keyword">type</span> t = <span class="constructor">Entry</span>.t list
  <span class="keyword">let</span> t = <span class="constructor">Irmin</span>.<span class="constructor">Type</span>.(list <span class="constructor">Entry</span>.t)

  <span class="keyword">let</span> empty = []

  <span class="keyword">let</span> pp ppf l = <span class="constructor">List</span>.iter (<span class="constructor">Fmt</span>.pf ppf <span class="string">"%a\n"</span> <span class="constructor">Entry</span>.pp ) (<span class="constructor">List</span>.rev l)

  <span class="keyword">let</span> of_string str =
    <span class="keyword">let</span> lines = <span class="constructor">String</span>.cuts ~sep:<span class="string">"\n"</span> str <span class="keyword">in</span>
    <span class="keyword">try</span>
      <span class="constructor">List</span>.fold_left (<span class="keyword">fun</span> acc l <span class="keywordsign">-&gt;</span>
          <span class="keyword">match</span> <span class="constructor">Entry</span>.of_string l <span class="keyword">with</span>
          <span class="keywordsign">|</span> <span class="constructor">Ok</span> x           <span class="keywordsign">-&gt;</span> x :: acc
          <span class="keywordsign">|</span> <span class="constructor">Error</span> (<span class="keywordsign">`</span><span class="constructor">Msg</span> e) <span class="keywordsign">-&gt;</span> failwith e
        ) [] lines
      |&gt; <span class="keyword">fun</span> l <span class="keywordsign">-&gt;</span> <span class="constructor">Ok</span> l
    <span class="keyword">with</span> <span class="constructor">Failure</span> e <span class="keywordsign">-&gt;</span>
      <span class="constructor">Error</span> (<span class="keywordsign">`</span><span class="constructor">Msg</span> e)

  <span class="keyword">let</span> timestamp = <span class="keyword">function</span>
    <span class="keywordsign">|</span> [] <span class="keywordsign">-&gt;</span> 0
    <span class="keywordsign">|</span> e :: _ <span class="keywordsign">-&gt;</span> <span class="constructor">Entry</span>.timestamp e

  <span class="keyword">let</span> newer_than timestamp file =
    <span class="keyword">let</span> <span class="keyword">rec</span> aux acc = <span class="keyword">function</span>
      <span class="keywordsign">|</span> [] <span class="keywordsign">-&gt;</span> <span class="constructor">List</span>.rev acc
      <span class="keywordsign">|</span> h:: _ <span class="keyword">when</span> <span class="constructor">Entry</span>.timestamp h &lt;= timestamp <span class="keywordsign">-&gt;</span> <span class="constructor">List</span>.rev acc
      <span class="keywordsign">|</span> h::t <span class="keywordsign">-&gt;</span> aux (h::acc) t
    <span class="keyword">in</span>
    aux [] file

  <span class="keyword">let</span> merge ~old t1 t2 =
    <span class="keyword">let</span> <span class="keyword">open</span> <span class="constructor">Irmin</span>.<span class="constructor">Merge</span>.<span class="constructor">Infix</span> <span class="keyword">in</span>
    old () &gt;&gt;=* <span class="keyword">fun</span> old <span class="keywordsign">-&gt;</span>
    <span class="keyword">let</span> old = <span class="keyword">match</span> old <span class="keyword">with</span> <span class="constructor">None</span> <span class="keywordsign">-&gt;</span> [] <span class="keywordsign">|</span> <span class="constructor">Some</span> o <span class="keywordsign">-&gt;</span> o <span class="keyword">in</span>
    <span class="keyword">let</span> ts = timestamp old <span class="keyword">in</span>
    <span class="keyword">let</span> t1 = newer_than ts t1 <span class="keyword">in</span>
    <span class="keyword">let</span> t2 = newer_than ts t2 <span class="keyword">in</span>
    <span class="keyword">let</span> t3 = <span class="constructor">List</span>.sort <span class="constructor">Entry</span>.compare (<span class="constructor">List</span>.rev_append t1 t2) <span class="keyword">in</span>
    <span class="constructor">Irmin</span>.<span class="constructor">Merge</span>.ok (<span class="constructor">List</span>.rev_append t3 old)

  <span class="keyword">let</span> merge = <span class="constructor">Irmin</span>.<span class="constructor">Merge</span>.(option (v t merge))

  <span class="keyword">let</span> add t e = e :: t

<span class="keyword">end</span> </code></pre>
<p>

    <b>Note:</b> The serialisation primitives used in that example are
    not very efficient in this case as they parse the file
    every-time. For real usage, you would write buffered versions of
    <code class="code"><span class="constructor">Log</span>.pp</code> and <code class="code"><span class="constructor">Log</span>.of_string</code>.
<p>

    To persist the log file on disk, we need to choose a backend. We
    show here how to use the on-disk <code class="code"><span class="constructor">Git</span></code> backend on Unix.
<p>

<pre class="codepre"><code class="code">  <span class="comment">(* Build an Irmin store containing log files. *)</span>
  <span class="keyword">module</span> <span class="constructor">S</span> = <span class="constructor">Irmin_unix</span>.<span class="constructor">Git</span>.<span class="constructor">FS</span>.<span class="constructor">KV</span>(<span class="constructor">Log</span>)

  <span class="comment">(* Set-up the local configuration of the Git repository. *)</span>
  <span class="keyword">let</span> config = <span class="constructor">Irmin_git</span>.config ~root:<span class="string">"/tmp/irmin/test"</span> ~bare:<span class="keyword">true</span> ()

  <span class="comment">(* Set-up the commit info function *)</span>
  <span class="keyword">let</span> info fmt = <span class="constructor">Irmin_unix</span>.info ~author:<span class="string">"logger"</span> fmt
</code></pre>
<p>

  We can now define a toy example to use our mergeable log files.
<p>

<pre class="codepre"><code class="code">  <span class="keyword">open</span> <span class="constructor">Lwt</span>.<span class="constructor">Infix</span>

  <span class="comment">(* Name of the log file. *)</span>
  <span class="keyword">let</span> file = [ <span class="string">"local"</span>; <span class="string">"debug"</span> ]

  <span class="comment">(* Read the entire log file. *)</span>
  <span class="keyword">let</span> read_file t =
    <span class="constructor">S</span>.find t file &gt;|= <span class="keyword">function</span>
    <span class="keywordsign">|</span> <span class="constructor">None</span>   <span class="keywordsign">-&gt;</span> []
    <span class="keywordsign">|</span> <span class="constructor">Some</span> l <span class="keywordsign">-&gt;</span> l

  <span class="comment">(* Persist a new entry in the log. *)</span>
  <span class="keyword">let</span> log t fmt =
    <span class="constructor">Fmt</span>.kstrf (<span class="keyword">fun</span> message <span class="keywordsign">-&gt;</span>
        read_file t &gt;&gt;= <span class="keyword">fun</span> logs <span class="keywordsign">-&gt;</span>
        <span class="keyword">let</span> logs = <span class="constructor">Log</span>.add logs (<span class="constructor">Entry</span>.v message) <span class="keyword">in</span>
        <span class="constructor">S</span>.set t (info <span class="string">"Adding a new entry"</span>) file logs
      ) fmt

  <span class="keyword">let</span> () =
    <span class="constructor">Lwt_main</span>.run <span class="keyword">begin</span>
      <span class="constructor">S</span>.<span class="constructor">Repo</span>.v config &gt;&gt;= <span class="constructor">S</span>.master
      &gt;&gt;= <span class="keyword">fun</span> t  <span class="keywordsign">-&gt;</span> log t <span class="string">"Adding a new log entry"</span>
      &gt;&gt;= <span class="keyword">fun</span> () <span class="keywordsign">-&gt;</span> <span class="constructor">Irmin</span>.clone_force ~src:t ~dst:<span class="string">"x"</span>
      &gt;&gt;= <span class="keyword">fun</span> x  <span class="keywordsign">-&gt;</span> log x <span class="string">"Adding new stuff to x"</span>
      &gt;&gt;= <span class="keyword">fun</span> () <span class="keywordsign">-&gt;</span> log x <span class="string">"Adding more stuff to x"</span>
      &gt;&gt;= <span class="keyword">fun</span> () <span class="keywordsign">-&gt;</span> log x <span class="string">"More. Stuff. To x."</span>
      &gt;&gt;= <span class="keyword">fun</span> () <span class="keywordsign">-&gt;</span> log t <span class="string">"I can add stuff on t also"</span>
      &gt;&gt;= <span class="keyword">fun</span> () <span class="keywordsign">-&gt;</span> log t <span class="string">"Yes. On t!"</span>
      &gt;&gt;= <span class="keyword">fun</span> () <span class="keywordsign">-&gt;</span> <span class="constructor">S</span>.merge (info <span class="string">"Merging x into t"</span>) x ~into:t
      &gt;|= <span class="keyword">function</span> <span class="constructor">Ok</span> () <span class="keywordsign">-&gt;</span> () <span class="keywordsign">|</span> <span class="constructor">Errror</span> _ <span class="keywordsign">-&gt;</span> failwith <span class="string">"merge conflict!"</span>
    <span class="keyword">end</span>
</code></pre><br>
<br>
<h1 id="1_Helpers">Helpers</h1><br>

<pre><span id="VALremote_store"><span class="keyword">val</span> remote_store</span> : <code class="type">(module Irmin.S with type t = 'a) -> 'a -> <a href="Irmin.html#TYPEremote">remote</a></code></pre><div class="info ">
<code class="code">remote_store&nbsp;t</code> is the remote corresponding to the local store
    <code class="code">t</code>. Synchronization is done by importing and exporting store
    slices, so this is usually much slower than native
    synchronization using <a href="Irmin.html#VALremote_uri"><code class="code"><span class="constructor">Irmin</span>.remote_uri</code></a> but it works for all
    backends.<br>
</div>

<pre><span class="keyword">module type</span> <a href="Irmin.SYNC.html">SYNC</a> = <code class="code"><span class="keyword">sig</span></code> <a href="Irmin.SYNC.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
<code class="code"><span class="constructor">SYNC</span></code> provides functions to synchronization an Irmin store with
    local and remote Irmin stores.
</div>

<pre><span class="keyword">module</span> <a href="Irmin.Sync.html">Sync</a>: <div class="sig_block"><code class="code"><span class="keyword">functor</span>&nbsp;(</code><code class="code"><span class="constructor">S</span></code><code class="code">&nbsp;:&nbsp;</code><code class="type"><a href="Irmin.S.html">S</a></code><code class="code">)&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;</code><code class="type"><a href="Irmin.SYNC.html">SYNC</a></code><code class="type">  with type db = S.t and type commit = S.commit</code></div></pre><div class="info">
The default <code class="code"><span class="constructor">Sync</span></code> implementation.
</div>

<pre><span class="keyword">module</span> <a href="Irmin.Dot.html">Dot</a>: <div class="sig_block"><code class="code"><span class="keyword">functor</span>&nbsp;(</code><code class="code"><span class="constructor">S</span></code><code class="code">&nbsp;:&nbsp;</code><code class="type"><a href="Irmin.S.html">S</a></code><code class="code">)&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;</code><code class="code"><span class="keyword">sig</span></code> <a href="Irmin.Dot.html">..</a> <code class="code"><span class="keyword">end</span></code></div></pre><div class="info">
<code class="code"><span class="constructor">Dot</span></code> provides functions to export a store to the Graphviz `dot`
    format.
</div>
<br>
<h1 id="backend">Backends</h1>
<p>

    API to create new Irmin backends. A backend is an implementation
    exposing either a concrete implementation of <a href="Irmin.S.html"><code class="code"><span class="constructor">Irmin</span>.<span class="constructor">S</span></code></a> or a functor
    providing <a href="Irmin.S.html"><code class="code"><span class="constructor">Irmin</span>.<span class="constructor">S</span></code></a> once applied.
<p>

    There are two ways to create a concrete <a href="Irmin.S.html"><code class="code"><span class="constructor">Irmin</span>.<span class="constructor">S</span></code></a> implementation:
<p>

    <ul>
<li><a href="Irmin.Make.html"><code class="code"><span class="constructor">Irmin</span>.<span class="constructor">Make</span></code></a> creates a store where all the objects are stored in the
    same store, using the same internal keys format and a custom binary
    format based on <a href="https://github.com/janestreet/bin_prot">bin_prot</a>,
    with no native synchronization primitives: it is usually what is
    needed to quickly create a new backend.</li>
<li><a href="Irmin.Make_ext.html"><code class="code"><span class="constructor">Irmin</span>.<span class="constructor">Make_ext</span></code></a> creates a store with a <em>deep</em> embedding of each
    of the internal stores into separate store, with a total control over
    the binary format and using the native synchronization protocols
    when available.</li>
</ul>
<br>

<pre><span class="keyword">module type</span> <a href="Irmin.AO_MAKER.html">AO_MAKER</a> = <code class="code"><span class="keyword">functor</span>&nbsp;(</code><code class="code"><span class="constructor">K</span></code><code class="code">&nbsp;:&nbsp;</code><code class="type"><a href="Irmin.Hash.S.html">Hash.S</a></code><code class="code">)&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;</code><code class="code"><span class="keyword">functor</span>&nbsp;(</code><code class="code"><span class="constructor">V</span></code><code class="code">&nbsp;:&nbsp;</code><code class="type"><a href="Irmin.Contents.Raw.html">Contents.Raw</a></code><code class="code">)&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;</code><code class="code"><span class="keyword">sig</span></code> <a href="Irmin.AO_MAKER.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
<code class="code"><span class="constructor">AO_MAKER</span></code> is the signature exposed by append-only store
    backends.
</div>

<pre><span class="keyword">module type</span> <a href="Irmin.LINK_MAKER.html">LINK_MAKER</a> = <code class="code"><span class="keyword">functor</span>&nbsp;(</code><code class="code"><span class="constructor">K</span></code><code class="code">&nbsp;:&nbsp;</code><code class="type"><a href="Irmin.Hash.S.html">Hash.S</a></code><code class="code">)&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;</code><code class="code"><span class="keyword">sig</span></code> <a href="Irmin.LINK_MAKER.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
<code class="code"><span class="constructor">LINK_MAKER</span></code> is the signature exposed by store which enable adding
    relation between keys.
</div>

<pre><span class="keyword">module type</span> <a href="Irmin.RW_MAKER.html">RW_MAKER</a> = <code class="code"><span class="keyword">functor</span>&nbsp;(</code><code class="code"><span class="constructor">K</span></code><code class="code">&nbsp;:&nbsp;</code><code class="type"><a href="Irmin.Contents.Conv.html">Contents.Conv</a></code><code class="code">)&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;</code><code class="code"><span class="keyword">functor</span>&nbsp;(</code><code class="code"><span class="constructor">V</span></code><code class="code">&nbsp;:&nbsp;</code><code class="type"><a href="Irmin.Contents.Conv.html">Contents.Conv</a></code><code class="code">)&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;</code><code class="code"><span class="keyword">sig</span></code> <a href="Irmin.RW_MAKER.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
<code class="code"><span class="constructor">RW_MAKER</span></code> is the signature exposed by read-write store
    backends.
</div>

<pre><span class="keyword">module</span> <a href="Irmin.Make.html">Make</a>: <div class="sig_block"><code class="code"><span class="keyword">functor</span>&nbsp;(</code><code class="code"><span class="constructor">AO</span></code><code class="code">&nbsp;:&nbsp;</code><code class="type"><a href="Irmin.AO_MAKER.html">AO_MAKER</a></code><code class="code">)&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;</code><div class="sig_block"><code class="code"><span class="keyword">functor</span>&nbsp;(</code><code class="code"><span class="constructor">RW</span></code><code class="code">&nbsp;:&nbsp;</code><code class="type"><a href="Irmin.RW_MAKER.html">RW_MAKER</a></code><code class="code">)&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;</code><code class="type"><a href="Irmin.S_MAKER.html">S_MAKER</a></code><code class="type"> </code></div></div></pre><div class="info">
Simple store creator.
</div>

<pre><span class="keyword">module</span> <a href="Irmin.Make_ext.html">Make_ext</a>: <div class="sig_block"><code class="code"><span class="keyword">functor</span>&nbsp;(</code><code class="code"><span class="constructor">P</span></code><code class="code">&nbsp;:&nbsp;</code><code class="type"><a href="Irmin.Private.S.html">Private.S</a></code><code class="code">)&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;</code><code class="type"><a href="Irmin.S.html">S</a></code><code class="type"> 
  with type key = P.Node.Path.t
   and type contents = P.Contents.value
   and type branch = P.Branch.key
   and type Commit.Hash.t = P.Commit.key
   and type Tree.Hash.t = P.Node.key
   and type Contents.Hash.t = P.Contents.key
   and type step = P.Node.Path.step
   and type metadata = P.Node.Val.metadata
   and type Key.step = P.Node.Path.step
   and type Repo.t = P.Repo.t</code></div></pre><div class="info">
Advanced store creator.
</div>
</body></html>