<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type">
<link rel="Start" href="index.html">
<link rel="next" href="Irmin_mem.html">
<link rel="Up" href="index.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="Irmin" rel="Chapter" href="Irmin.html">
<link title="Irmin_mem" rel="Chapter" href="Irmin_mem.html">
<link title="Irmin_unix" rel="Chapter" href="Irmin_unix.html"><link title="Preliminaries" rel="Section" href="#1_Preliminaries">
<link title="Stores" rel="Section" href="#1_Stores">
<link title="User-Defined Contents" rel="Section" href="#1_UserDefinedContents">
<link title="High-level Stores" rel="Section" href="#1_HighlevelStores">
<link title="Backends" rel="Section" href="#backend">
<title>Irmin</title>
</head>
<body>
<div class="navbar">&nbsp;<a class="up" href="index.html" title="Index">Up</a>
&nbsp;<a class="post" href="Irmin_mem.html" title="Irmin_mem">Next</a>
</div>
<h1>Module <a href="type_Irmin.html">Irmin</a></h1>

<pre><span class="keyword">module</span> Irmin: <code class="code">sig</code> <a href="Irmin.html">..</a> <code class="code">end</code></pre><div class="info module top">
Irmin public API.
<p>

    Irmin is a library to design and use persistent stores with
    built-in snapshot, branching and reverting mechanisms. Irmin uses
    concepts similar to <a href="http://git-scm.com/">Git</a> but it exposes
    them as a high level library instead of a complex command-line
    frontend. It features a <em>bidirectional</em> Git backend,
    fully-compatible with the usual Git tools and workflows.
<p>

    Irmin is designed to use a large variety of backends. It is
    written in pure OCaml and does not depend on external C stubs; it
    is thus very portable and aims is to run everywhere, from Linux to
    Xen unikernels.
<p>

    <em>Release %%VERSION%% - %%MAINTAINER%% </em><br>
</div>
<hr width="100%">

<pre><span id="VALversion"><span class="keyword">val</span> version</span> : <code class="type">string</code></pre><div class="info ">
The version of the library.<br>
</div>
<br>
<h1 id="1_Preliminaries">Preliminaries</h1><br>

<pre><span class="keyword">module</span> <a href="Irmin.Hum.html">Hum</a>: <code class="code">sig</code> <a href="Irmin.Hum.html">..</a> <code class="code">end</code></pre><div class="info">
Serializable data with reversible human-readable
    representations.
</div>

<pre><span class="keyword">module</span> <a href="Irmin.Task.html">Task</a>: <code class="code">sig</code> <a href="Irmin.Task.html">..</a> <code class="code">end</code></pre><div class="info">
Tasks are used to keep track of the origin of reads and writes in
    the store.
</div>

<pre><span class="keyword">module</span> <a href="Irmin.Merge.html">Merge</a>: <code class="code">sig</code> <a href="Irmin.Merge.html">..</a> <code class="code">end</code></pre><div class="info">
<code class="code">Merge</code> provides functions to build custom 3-way merge operators
    for various user-defined contents.
</div>
<br>
<h1 id="1_Stores">Stores</h1><br>

<pre><span id="TYPEtask"><span class="keyword">type</span> <code class="type"></code>task</span> = <code class="type">Task.t</code> </pre>
<div class="info ">
The type for user-defined tasks. See <a href="Irmin.Task.html">Task</a>.<br>
</div>


<pre><span id="TYPEconfig"><span class="keyword">type</span> <code class="type"></code>config</span> </pre>
<div class="info ">
The type for backend-specific configuration values.
<p>

    Every backend has different configuration options, which are kept
    abstract to the user.<br>
</div>

<br>
An Irmin store is automatically built from a number of lower-level
    stores, implementing fewer operations, such as <a href="Irmin.AO.html">append-only</a>
    and <a href="Irmin.RW.html">read-write</a> stores. These low-level stores are provided
    by various backends.<br>

<pre><span class="keyword">module type</span> <a href="Irmin.RO.html">RO</a> = <code class="code">sig</code> <a href="Irmin.RO.html">..</a> <code class="code">end</code></pre><div class="info">
Read-only stores.
</div>

<pre><span class="keyword">module type</span> <a href="Irmin.AO.html">AO</a> = <code class="code">sig</code> <a href="Irmin.AO.html">..</a> <code class="code">end</code></pre><div class="info">
Append-only store.
</div>

<pre><span class="keyword">module type</span> <a href="Irmin.RW.html">RW</a> = <code class="code">sig</code> <a href="Irmin.RW.html">..</a> <code class="code">end</code></pre><div class="info">
Read-write stores.
</div>

<pre><span class="keyword">module type</span> <a href="Irmin.HRW.html">HRW</a> = <code class="code">sig</code> <a href="Irmin.HRW.html">..</a> <code class="code">end</code></pre><div class="info">
Hierarchical read-write stores.
</div>

<pre><span class="keyword">module type</span> <a href="Irmin.BC.html">BC</a> = <code class="code">sig</code> <a href="Irmin.BC.html">..</a> <code class="code">end</code></pre><div class="info">
Branch-consistent stores.
</div>
<br>
<h1 id="1_UserDefinedContents">User-Defined Contents</h1><br>

<pre><span class="keyword">module</span> <a href="Irmin.Path.html">Path</a>: <code class="code">sig</code> <a href="Irmin.Path.html">..</a> <code class="code">end</code></pre><div class="info">
Store paths.
</div>

<pre><span class="keyword">module</span> <a href="Irmin.Hash.html">Hash</a>: <code class="code">sig</code> <a href="Irmin.Hash.html">..</a> <code class="code">end</code></pre><div class="info">
Hashing functions.
</div>

<pre><span class="keyword">module</span> <a href="Irmin.Contents.html">Contents</a>: <code class="code">sig</code> <a href="Irmin.Contents.html">..</a> <code class="code">end</code></pre><div class="info">
<code class="code">Contents</code> specifies how user-defined contents need to be <em>    serializable</em> and <em>mergeable</em>.
</div>

<pre><span class="keyword">module</span> <a href="Irmin.Tag.html">Tag</a>: <code class="code">sig</code> <a href="Irmin.Tag.html">..</a> <code class="code">end</code></pre><div class="info">
User-defined tags.
</div>
<br>
<h1 id="1_HighlevelStores">High-level Stores</h1>
<p>

    An Irmin store is a branch-consistent store where keys are lists
    of steps.
<p>

    An example is a Git repository where keys are filenames, <em>i.e.</em>
    list of <code class="code">'\'</code>-separated strings. More complex examples are
    structured values, where steps might contains first-class fields
    accessors and array offsets.
<p>

    Irmin provides the follow gin features:
<p>

    <ul>
<li>Support for fast <a href="Irmin.BC.html">clones</a>, branches and merges, in a
    fashion very similar to Git.</li>
<li>Efficient <a href="Irmin.View.html">staging areas</a> for fast, transient,
    in-memory operations.</li>
<li>Space efficient <a href="Irmin.Snapshot.html">snapshots</a> and fast and consistent
    rollback operations.</li>
<li>Fast <a href="Irmin.Sync.html">synchronization</a> primitives between remote
    stores, using native backend protocols (as the Git protocol) when
    available.</li>
</ul>
<br>

<pre><span class="keyword">module</span> <a href="Irmin.Private.html">Private</a>: <code class="code">sig</code> <a href="Irmin.Private.html">..</a> <code class="code">end</code></pre><div class="info">
<code class="code">Private</code> defines functions only useful for creating new
    backends.
</div>

<pre><span class="keyword">module type</span> <a href="Irmin.S.html">S</a> = <code class="code">sig</code> <a href="Irmin.S.html">..</a> <code class="code">end</code></pre><div class="info">
Signature for Irmin stores.
</div>

<pre><span id="TYPEremote"><span class="keyword">type</span> <code class="type"></code>remote</span> </pre>
<div class="info ">
The type for remote stores.<br>
</div>


<pre><span id="VALremote_uri"><span class="keyword">val</span> remote_uri</span> : <code class="type">string -> <a href="Irmin.html#TYPEremote">remote</a></code></pre><div class="info ">
<code class="code">remote_uri s</code> is the remote store located at <code class="code">uri</code>. Use the
    optimized native synchronization protocol when available for the
    given backend.<br>
</div>

<pre><span id="VALremote_store"><span class="keyword">val</span> remote_store</span> : <code class="type">(module Irmin.S with type t = 'a) -> 'a -> <a href="Irmin.html#TYPEremote">remote</a></code></pre><div class="info ">
<code class="code">remote_store t</code> is the remote corresponding to the local store
    <code class="code">t</code>. Synchronization is done by importing and exporting store
    <a href="Irmin.BC.html#TYPEslice">slices</a>, so this is usually much slower than native
    synchronization using <a href="Irmin.html#VALremote_uri"><code class="code">Irmin.remote_uri</code></a> but it works for all
    backends.<br>
</div>

<pre><span class="keyword">module</span> <a href="Irmin.Sync.html">Sync</a>: <div class="sig_block"><code class="code">functor (</code><code class="code">S</code><code class="code"> : </code><code class="type"><a href="Irmin.S.html">S</a></code><code class="code">) -&gt; </code><code class="code">sig</code> <a href="Irmin.Sync.html">..</a> <code class="code">end</code></div></pre><div class="info">
<code class="code">Sync</code> provides functions to synchronization an Irmin store with
    local and remote Irmin stores.
</div>

<pre><span class="keyword">module</span> <a href="Irmin.View.html">View</a>: <div class="sig_block"><code class="code">functor (</code><code class="code">S</code><code class="code"> : </code><code class="type"><a href="Irmin.S.html">S</a></code><code class="code">) -&gt; </code><code class="code">sig</code> <a href="Irmin.View.html">..</a> <code class="code">end</code></div></pre><div class="info">
<code class="code">View</code> provides an in-memory partial mirror of the store, with
    lazy reads and delayed write.
</div>

<pre><span class="keyword">module</span> <a href="Irmin.Snapshot.html">Snapshot</a>: <div class="sig_block"><code class="code">functor (</code><code class="code">S</code><code class="code"> : </code><code class="type"><a href="Irmin.S.html">S</a></code><code class="code">) -&gt; </code><code class="code">sig</code> <a href="Irmin.Snapshot.html">..</a> <code class="code">end</code></div></pre><div class="info">
<code class="code">Snapshot</code> provides read-only, space-efficient, checkpoints of a
    store.
</div>

<pre><span class="keyword">module</span> <a href="Irmin.Dot.html">Dot</a>: <div class="sig_block"><code class="code">functor (</code><code class="code">S</code><code class="code"> : </code><code class="type"><a href="Irmin.S.html">S</a></code><code class="code">) -&gt; </code><code class="code">sig</code> <a href="Irmin.Dot.html">..</a> <code class="code">end</code></div></pre><div class="info">
<code class="code">Dot</code> provides functions to export a store to the Graphviz `dot`
    format.
</div>
<br>
<h1 id="backend">Backends</h1><br>
<br>
API to create new Irmin backends. A backend is an implementation
    exposing either a concrete implementation of <a href="Irmin.S.html"><code class="code">Irmin.S</code></a> or a functor
    providing <a href="Irmin.S.html"><code class="code">Irmin.S</code></a> once applied.
<p>

    There are two ways to create a concrete <a href="Irmin.S.html"><code class="code">Irmin.S</code></a> implementation:
<p>

    <ul>
<li><a href="Irmin.Make.html"><code class="code">Irmin.Make</code></a> creates a store where all the objects are stored in the
    same store, using the same internal keys format and a custom binary
    format based on <a href="https://github.com/janestreet/bin_prot">bin_prot</a>,
    with no native synchronization primitives: it is usually what is
    needed to quickly create a new backend.</li>
<li><a href="Irmin.Make_ext.html"><code class="code">Irmin.Make_ext</code></a> creates a store with a <em>deep</em> embedding of each
    of the internal stores into separate store, with a total control over
    the binary format and using the native synchronization protocols
    when available. This is mainly used by the Git backend, but could
    be used for other similar backends as well in the future.</li>
</ul>
<br>

<pre><span class="keyword">module type</span> <a href="Irmin.AO_MAKER.html">AO_MAKER</a> = <code class="code">functor (</code><code class="code">K</code><code class="code"> : </code><code class="type"><a href="Irmin.Hash.S.html">Hash.S</a></code><code class="code">) -&gt; </code><code class="code">functor (</code><code class="code">V</code><code class="code"> : </code><code class="type">Tc.S0</code><code class="code">) -&gt; </code><code class="type"><a href="Irmin.AO.html">AO</a></code><code class="type">  with type key = K.t and type value = V.t</code></pre><div class="info">
<code class="code">AO_MAKER</code> is the signature exposed by any backend providing
    append-only stores.
</div>

<pre><span class="keyword">module type</span> <a href="Irmin.RW_MAKER.html">RW_MAKER</a> = <code class="code">functor (</code><code class="code">K</code><code class="code"> : </code><code class="type"><a href="Irmin.Hum.S.html">Hum.S</a></code><code class="code">) -&gt; </code><code class="code">functor (</code><code class="code">V</code><code class="code"> : </code><code class="type"><a href="Irmin.Hash.S.html">Hash.S</a></code><code class="code">) -&gt; </code><code class="type"><a href="Irmin.RW.html">RW</a></code><code class="type">  with type key = K.t and type value = V.t</code></pre><div class="info">
<code class="code">RW_MAKER</code> is the signature exposed by any backend providing
    read-write stores.
</div>

<pre><span class="keyword">module type</span> <a href="Irmin.S_MAKER.html">S_MAKER</a> = <code class="code">functor (</code><code class="code">P</code><code class="code"> : </code><code class="type"><a href="Irmin.Path.S.html">Path.S</a></code><code class="code">) -&gt; </code><code class="code">functor (</code><code class="code">C</code><code class="code"> : </code><code class="type"><a href="Irmin.Contents.S.html">Contents.S</a></code><code class="code">) -&gt; </code><code class="code">functor (</code><code class="code">T</code><code class="code"> : </code><code class="type"><a href="Irmin.Tag.S.html">Tag.S</a></code><code class="code">) -&gt; </code><code class="code">functor (</code><code class="code">H</code><code class="code"> : </code><code class="type"><a href="Irmin.Hash.S.html">Hash.S</a></code><code class="code">) -&gt; </code><code class="type"><a href="Irmin.S.html">S</a></code><code class="type">  with type step = P.step
       and type value = C.t
       and type tag = T.t
       and type head = H.t</code></pre><div class="info">
<code class="code">S_MAKER</code> is the signature exposed by any backend providing <a href="Irmin.S.html"><code class="code">Irmin.S</code></a>
    implementations.
</div>

<pre><span class="keyword">module</span> <a href="Irmin.Make.html">Make</a>: <div class="sig_block"><code class="code">functor (</code><code class="code">AO</code><code class="code"> : </code><code class="type"><a href="Irmin.AO_MAKER.html">AO_MAKER</a></code><code class="code">) -&gt; </code><div class="sig_block"><code class="code">functor (</code><code class="code">RW</code><code class="code"> : </code><code class="type"><a href="Irmin.RW_MAKER.html">RW_MAKER</a></code><code class="code">) -&gt; </code><code class="type"><a href="Irmin.S_MAKER.html">S_MAKER</a></code><code class="type"> </code></div></div></pre><div class="info">
Simple store creator.
</div>

<pre><span class="keyword">module</span> <a href="Irmin.Make_ext.html">Make_ext</a>: <div class="sig_block"><code class="code">functor (</code><code class="code">P</code><code class="code"> : </code><code class="type"><a href="Irmin.Private.S.html">Private.S</a></code><code class="code">) -&gt; </code><code class="type"><a href="Irmin.S.html">S</a></code><code class="type"> 
  with type step = P.Node.Path.step
   and type value = P.Contents.value
   and type tag = P.Tag.key
   and type head = P.Tag.value</code></div></pre><div class="info">
Advanced store creator.
</div>
</body></html>