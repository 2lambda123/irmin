<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type">
<link rel="Start" href="index.html">
<link rel="Up" href="index.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="Irmin" rel="Chapter" href="Irmin.html"><link title="User-Defined Contents" rel="Section" href="#1_UserDefinedContents">
<link title="Stores" rel="Section" href="#1_Stores">
<link title="Backends" rel="Section" href="#backend">
<title>Irmin</title>
</head>
<body>
<div class="navbar">&nbsp;<a class="up" href="index.html" title="Index">Up</a>
&nbsp;</div>
<h1>Module <a href="type_Irmin.html">Irmin</a></h1>

<pre><span class="keyword">module</span> Irmin: <code class="code">sig</code> <a href="Irmin.html">..</a> <code class="code">end</code></pre><div class="info module top">
A library for persistent stores following the same design
    principle as Git.
<p>

    Irmin is a distributed and history-preserving library for
    persistent stores with built-in snapshot, branching and reverting
    mechanisms. It is designed to use a large variety of
    backends. Irmin is written in pure OCaml and does not depend on
    external C stubs; it aims is to run everywhere, from Linux to Xen
    unikernels -- and can be be compiled to JavaScipt to run in a
    browser.
<p>

    FIXME<br>
</div>
<hr width="100%">
<br>
<h1 id="1_UserDefinedContents">User-Defined Contents</h1><br>
<br>
Defining the <em>contents</em> of the store and how <em>merge</em> conflicts
    between different version of the same contents should be
    resolved.<br>

<pre><span class="keyword">module</span> <a href="Irmin.Merge.html">Merge</a>: <code class="code">sig</code> <a href="Irmin.Merge.html">..</a> <code class="code">end</code></pre><div class="info">
<code class="code">Merge</code> provides functions to build custom 3-way merge operators
    for various user-defined contents.
</div>

<pre><span class="keyword">module</span> <a href="Irmin.Contents.html">Contents</a>: <code class="code">sig</code> <a href="Irmin.Contents.html">..</a> <code class="code">end</code></pre><div class="info">
<code class="code">Contents</code> specifies how user-defined contents need to be <em>    serializable</em> and <em>mergeable</em>.
</div>

<pre><span class="keyword">module</span> <a href="Irmin.Tag.html">Tag</a>: <code class="code">sig</code> <a href="Irmin.Tag.html">..</a> <code class="code">end</code></pre><div class="info">
User-defined tags.
</div>

<pre><span class="keyword">module</span> <a href="Irmin.Step.html">Step</a>: <code class="code">sig</code> <a href="Irmin.Step.html">..</a> <code class="code">end</code></pre><div class="info">
<code class="code">Step</code> provides functions to manipulate keys: Irmin
    <a href="Irmin.S.html">stores</a> use list of steps as keys.
</div>

<pre><span class="keyword">module</span> <a href="Irmin.Hash.html">Hash</a>: <code class="code">sig</code> <a href="Irmin.Hash.html">..</a> <code class="code">end</code></pre><div class="info">
<code class="code">Hash</code> provides user-defined hash function to digest serialized
    contents.
</div>
<br>
<h1 id="1_Stores">Stores</h1><br>

<pre><span id="TYPEtask"><span class="keyword">type</span> <code class="type"></code>task</span> </pre>
<div class="info ">
The type for user-defined tasks. See <a href="Irmin.Task.html">Task</a>.<br>
</div>


<pre><span id="TYPEconfig"><span class="keyword">type</span> <code class="type"></code>config</span> </pre>
<div class="info ">
The type for backend-specific configuration values. Every backend
    has different configuration options, which are kept abstract to
    the user.<br>
</div>

<br>
Irmin provides to the user a high-level store, with few
    interesting features:
<p>

    <ul>
<li>Support for fast <a href="Irmin.BC.html">clones</a>, branches and merges, in a
    fashion very similar to Git.</li>
<li>Efficient <a href="Irmin.S.View.html">staging areas</a> for fast, transient,
    in-memory operations.</li>
<li>Space efficient <a href="Irmin.S.Snapshot.html">snapshots</a> and fast and consistent
    rollback operations.</li>
<li>Fast <a href="Irmin.S.Sync.html">synchronization</a> primitives between remote
    stores, using native backend protocols (as the Git protocol) when
    available.</li>
</ul>

<p>

    An Irmin store is automatically built from a number of lower-level
    stores, implementing fewer operations, such as <a href="Irmin.AO.html">append-only</a>
    and <a href="Irmin.RW.html">read-write</a> stores. These low-level stores are provided
    by various backends.<br>

<pre><span class="keyword">module</span> <a href="Irmin.Task.html">Task</a>: <code class="code">sig</code> <a href="Irmin.Task.html">..</a> <code class="code">end</code></pre><div class="info">
Tasks are used to keep track of the origin of reads and writes in
    the store.
</div>

<pre><span class="keyword">module type</span> <a href="Irmin.RO.html">RO</a> = <code class="code">sig</code> <a href="Irmin.RO.html">..</a> <code class="code">end</code></pre><div class="info">
Read-only stores.
</div>

<pre><span class="keyword">module type</span> <a href="Irmin.AO.html">AO</a> = <code class="code">sig</code> <a href="Irmin.AO.html">..</a> <code class="code">end</code></pre><div class="info">
Append-only store.
</div>

<pre><span class="keyword">module type</span> <a href="Irmin.RW.html">RW</a> = <code class="code">sig</code> <a href="Irmin.RW.html">..</a> <code class="code">end</code></pre><div class="info">
Read-write stores.
</div>

<pre><span class="keyword">module type</span> <a href="Irmin.BC.html">BC</a> = <code class="code">sig</code> <a href="Irmin.BC.html">..</a> <code class="code">end</code></pre><div class="info">
Branch-consistent stores.
</div>

<pre><span class="keyword">module type</span> <a href="Irmin.S.html">S</a> = <code class="code">sig</code> <a href="Irmin.S.html">..</a> <code class="code">end</code></pre><div class="info">
Irmin high-level stores.
</div>
<br>
<h1 id="backend">Backends</h1><br>
<br>
A backend is an implementation exposing either a concrete
    implementation of <a href="Irmin.S.html"><code class="code">Irmin.S</code></a> or a functor providing <a href="Irmin.S.html"><code class="code">Irmin.S</code></a> once
    applied.<br>

<pre><span class="keyword">module type</span> <a href="Irmin.AO_MAKER.html">AO_MAKER</a> = <code class="code">functor (</code><code class="code">K</code><code class="code"> : </code><code class="type"><a href="Irmin.Hash.S.html">Hash.S</a></code><code class="code">) -&gt; </code><code class="code">functor (</code><code class="code">V</code><code class="code"> : </code><code class="type">Tc.S0</code><code class="code">) -&gt; </code><code class="type"><a href="Irmin.AO.html">AO</a></code><code class="type">  with type key = K.t and type value = V.t</code></pre><div class="info">
<code class="code">AO_MAKER</code> is the signature exposed by any backend providing
    append-only stores.
</div>

<pre><span class="keyword">module type</span> <a href="Irmin.RW_MAKER.html">RW_MAKER</a> = <code class="code">functor (</code><code class="code">K</code><code class="code"> : </code><code class="type">Tc.S0</code><code class="code">) -&gt; </code><code class="code">functor (</code><code class="code">V</code><code class="code"> : </code><code class="type">Tc.S0</code><code class="code">) -&gt; </code><code class="type"><a href="Irmin.RW.html">RW</a></code><code class="type">  with type key = K.t and type value = V.t</code></pre><div class="info">
<code class="code">RW_MAKER</code> is the signature exposed by any backend providing
    read-write stores.
</div>

<pre><span class="keyword">module type</span> <a href="Irmin.S_MAKER.html">S_MAKER</a> = <code class="code">functor (</code><code class="code">S</code><code class="code"> : </code><code class="type">Tc.S0</code><code class="code">) -&gt; </code><code class="code">functor (</code><code class="code">C</code><code class="code"> : </code><code class="type"><a href="Irmin.Contents.S.html">Contents.S</a></code><code class="code">) -&gt; </code><code class="code">functor (</code><code class="code">T</code><code class="code"> : </code><code class="type"><a href="Irmin.Tag.S.html">Tag.S</a></code><code class="code">) -&gt; </code><code class="code">functor (</code><code class="code">H</code><code class="code"> : </code><code class="type"><a href="Irmin.Hash.S.html">Hash.S</a></code><code class="code">) -&gt; </code><code class="type"><a href="Irmin.S.html">S</a></code><code class="type">  with type step = S.t
       and type value = C.t
       and type tag = T.t
       and type head = H.t</code></pre><div class="info">
<code class="code">S_MAKER</code> is the signature exposed by any backend providing <a href="Irmin.S.html"><code class="code">Irmin.S</code></a>
    implementations.
</div>

<pre><span class="keyword">module</span> <a href="Irmin.Private.html">Private</a>: <code class="code">sig</code> <a href="Irmin.Private.html">..</a> <code class="code">end</code></pre><div class="info">
<code class="code">Private</code> defines functions only useful for creting new
    backends.
</div>
</body></html>