<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=utf-8" http-equiv="Content-Type">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="Start" href="index.html">
<link rel="previous" href="Irmin.Info.html">
<link rel="next" href="Irmin.Diff.html">
<link rel="Up" href="Irmin.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="Irmin" rel="Chapter" href="Irmin.html">
<link title="Irmin_mem" rel="Chapter" href="Irmin_mem.html">
<link title="Irmin_fs" rel="Chapter" href="Irmin_fs.html">
<link title="Irmin_git" rel="Chapter" href="Irmin_git.html">
<link title="Irmin_http" rel="Chapter" href="Irmin_http.html">
<link title="Irmin_http_server" rel="Chapter" href="Irmin_http_server.html">
<link title="Irmin_unix" rel="Chapter" href="Irmin_unix.html"><link title="Merge Combinators" rel="Section" href="#1_MergeCombinators">
<link title="Basic Merges" rel="Section" href="#1_BasicMerges">
<link title="Counters and Multisets" rel="Section" href="#1_CountersandMultisets">
<link title="Maps and Association Lists" rel="Section" href="#1_MapsandAssociationLists">
<title>Irmin.Merge</title>
</head>
<body>
<div class="navbar"><a class="pre" href="Irmin.Info.html" title="Irmin.Info">Previous</a>
&nbsp;<a class="up" href="Irmin.html" title="Irmin">Up</a>
&nbsp;<a class="post" href="Irmin.Diff.html" title="Irmin.Diff">Next</a>
</div>
<h1>Module <a href="type_Irmin.Merge.html">Irmin.Merge</a></h1>

<pre><span class="keyword">module</span> Merge: <code class="code"><span class="keyword">sig</span></code> <a href="Irmin.Merge.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info module top">
<code class="code"><span class="constructor">Merge</span></code> provides functions to build custom 3-way merge operators
    for various user-defined contents.<br>
</div>
<hr width="100%">

<pre><span id="TYPEconflict"><span class="keyword">type</span> <code class="type"></code>conflict</span> = <code class="type">[ `Conflict of string ]</code> </pre>
<div class="info ">
The type for merge errors.<br>
</div>


<pre><span id="VALok"><span class="keyword">val</span> ok</span> : <code class="type">'a -> ('a, <a href="Irmin.Merge.html#TYPEconflict">conflict</a>) Result.result Lwt.t</code></pre><div class="info ">
Return <code class="code"><span class="constructor">Ok</span>&nbsp;x</code>.<br>
</div>

<pre><span id="VALconflict"><span class="keyword">val</span> conflict</span> : <code class="type">('a, unit, string, ('b, <a href="Irmin.Merge.html#TYPEconflict">conflict</a>) Result.result Lwt.t)<br>       Pervasives.format4 -> 'a</code></pre><div class="info ">
Return <code class="code"><span class="constructor">Error</span>&nbsp;(<span class="constructor">Conflict</span>&nbsp;str)</code>.<br>
</div>

<pre><span id="VALbind"><span class="keyword">val</span> bind</span> : <code class="type">('a, 'b) Result.result Lwt.t -><br>       ('a -> ('c, 'b) Result.result Lwt.t) -> ('c, 'b) Result.result Lwt.t</code></pre><div class="info ">
<code class="code">bind&nbsp;r&nbsp;f</code> is the merge result which behaves as of the
      application of the function <code class="code">f</code> to the return value of <code class="code">r</code>. If
      <code class="code">r</code> fails, <code class="code">bind&nbsp;r&nbsp;f</code> also fails, with the same conflict.<br>
</div>

<pre><span id="VALmap"><span class="keyword">val</span> map</span> : <code class="type">('a -> 'c) -> ('a, 'b) Result.result Lwt.t -> ('c, 'b) Result.result Lwt.t</code></pre><div class="info ">
<code class="code">map&nbsp;f&nbsp;m</code> maps the result of a merge. This is the same as <code class="code">bind<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m&nbsp;(<span class="keyword">fun</span>&nbsp;x&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;ok&nbsp;(f&nbsp;x))</code>.<br>
</div>
<br>
<h1 id="1_MergeCombinators">Merge Combinators</h1><br>

<pre><span id="TYPEpromise"><span class="keyword">type</span> <code class="type">'a</code> promise</span> = <code class="type">unit -> ('a option, <a href="Irmin.Merge.html#TYPEconflict">conflict</a>) Result.result Lwt.t</code> </pre>
<div class="info ">
An <code class="code"><span class="keywordsign">'</span>a</code> promise is a function which, when called, will
      eventually return a value type of <code class="code"><span class="keywordsign">'</span>a</code>. A promise is an
      optional, lazy and non-blocking value.<br>
</div>


<pre><span id="VALpromise"><span class="keyword">val</span> promise</span> : <code class="type">'a -> 'a <a href="Irmin.Merge.html#TYPEpromise">promise</a></code></pre><div class="info ">
<code class="code">promise&nbsp;a</code> is the promise containing <code class="code">a</code>.<br>
</div>

<pre><span id="VALmap_promise"><span class="keyword">val</span> map_promise</span> : <code class="type">('a -> 'b) -> 'a <a href="Irmin.Merge.html#TYPEpromise">promise</a> -> 'b <a href="Irmin.Merge.html#TYPEpromise">promise</a></code></pre><div class="info ">
<code class="code">map_promise&nbsp;f&nbsp;a</code> is the promise containing <code class="code">f</code> applied to what
      is promised by <code class="code">a</code>.<br>
</div>

<pre><span id="VALbind_promise"><span class="keyword">val</span> bind_promise</span> : <code class="type">'a <a href="Irmin.Merge.html#TYPEpromise">promise</a> -><br>       ('a -> 'b <a href="Irmin.Merge.html#TYPEpromise">promise</a>) -> 'b <a href="Irmin.Merge.html#TYPEpromise">promise</a></code></pre><div class="info ">
<code class="code">bind_promise&nbsp;a&nbsp;f</code> is the promise returned by <code class="code">f</code> applied to
      what is promised by <code class="code">a</code>.<br>
</div>

<pre><span id="TYPEf"><span class="keyword">type</span> <code class="type">'a</code> f</span> = <code class="type">old:'a <a href="Irmin.Merge.html#TYPEpromise">promise</a> -><br>       'a -> 'a -> ('a, <a href="Irmin.Merge.html#TYPEconflict">conflict</a>) Result.result Lwt.t</code> </pre>
<div class="info ">
Signature of a merge function. <code class="code">old</code> is the value of the
      least-common ancestor.
<p>

      <pre class="verbatim">              /----&gt; t1 ----\
      ----&gt; old              |--&gt; result
              \----&gt; t2 ----/
     </pre><br>
</div>


<pre><span id="TYPEt"><span class="keyword">type</span> <code class="type">'a</code> t</span> </pre>
<div class="info ">
The type for merge combinators.<br>
</div>


<pre><span id="VALv"><span class="keyword">val</span> v</span> : <code class="type">'a <a href="Irmin.Type.html#TYPEt">Irmin.Type.t</a> -> 'a <a href="Irmin.Merge.html#TYPEf">f</a> -> 'a <a href="Irmin.Merge.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">v&nbsp;dt&nbsp;f</code> create a merge combinator.<br>
</div>

<pre><span id="VALf"><span class="keyword">val</span> f</span> : <code class="type">'a <a href="Irmin.Merge.html#TYPEt">t</a> -> 'a <a href="Irmin.Merge.html#TYPEf">f</a></code></pre><div class="info ">
<code class="code">f&nbsp;m</code> is <code class="code">m</code>'s merge function.<br>
</div>

<pre><span id="VALseq"><span class="keyword">val</span> seq</span> : <code class="type">'a <a href="Irmin.Merge.html#TYPEt">t</a> list -> 'a <a href="Irmin.Merge.html#TYPEt">t</a></code></pre><div class="info ">
Call the merge functions in sequence. Stop as soon as one is <em>      not</em> returning a conflict.<br>
</div>

<pre><span id="VALlike"><span class="keyword">val</span> like</span> : <code class="type">'a <a href="Irmin.Type.html#TYPEt">Irmin.Type.t</a> -><br>       'b <a href="Irmin.Merge.html#TYPEt">t</a> -> ('a -> 'b) -> ('b -> 'a) -> 'a <a href="Irmin.Merge.html#TYPEt">t</a></code></pre><div class="info ">
Use the merge function defined in another domain. If the
      converting functions raise any exception the merge is a
      conflict.<br>
</div>

<pre><span id="VALlike_lwt"><span class="keyword">val</span> like_lwt</span> : <code class="type">'a <a href="Irmin.Type.html#TYPEt">Irmin.Type.t</a> -><br>       'b <a href="Irmin.Merge.html#TYPEt">t</a> -> ('a -> 'b Lwt.t) -> ('b -> 'a Lwt.t) -> 'a <a href="Irmin.Merge.html#TYPEt">t</a></code></pre><div class="info ">
Same as biject but with blocking domain
      converting functions.<br>
</div>
<br>
<h1 id="1_BasicMerges">Basic Merges</h1><br>

<pre><span id="VALdefault"><span class="keyword">val</span> default</span> : <code class="type">'a <a href="Irmin.Type.html#TYPEt">Irmin.Type.t</a> -> 'a <a href="Irmin.Merge.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">default&nbsp;t</code> is the default merge function for values of type
      <code class="code">t</code>. This is a simple merge function which supports changes in
      one branch at a time:
<p>

      <ul>
<li>if <code class="code">t1=old</code> then the result of the merge is <code class="code"><span class="constructor">OK</span>&nbsp;t2</code>;</li>
<li>if <code class="code">t2=old</code> then return <code class="code"><span class="constructor">OK</span>&nbsp;t1</code>;</li>
<li>otherwise the result is <code class="code"><span class="constructor">Conflict</span></code>.</li>
</ul>
<br>
</div>

<pre><span id="VALidempotent"><span class="keyword">val</span> idempotent</span> : <code class="type">'a <a href="Irmin.Type.html#TYPEt">Irmin.Type.t</a> -> 'a <a href="Irmin.Merge.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">idempotent&nbsp;t</code> is the default merge function for values of type
      <code class="code">t</code> using idempotent operations. It follows the same rules as
      the <a href="Irmin.Merge.html#VALdefault"><code class="code"><span class="constructor">Irmin</span>.<span class="constructor">Merge</span>.default</code></a> merge function but also adds:
<p>

      <ul>
<li>if <code class="code">t1=t2</code> then the result of the merge is <code class="code"><span class="constructor">OK</span>&nbsp;t1</code>.</li>
</ul>
<br>
</div>

<pre><span id="VALunit"><span class="keyword">val</span> unit</span> : <code class="type">unit <a href="Irmin.Merge.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">unit</code> is the default merge function for unit values.<br>
</div>

<pre><span id="VALbool"><span class="keyword">val</span> bool</span> : <code class="type">bool <a href="Irmin.Merge.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">bool</code> is the default merge function for booleans.<br>
</div>

<pre><span id="VALchar"><span class="keyword">val</span> char</span> : <code class="type">char <a href="Irmin.Merge.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">char</code> is the default merge function for characters.<br>
</div>

<pre><span id="VALint"><span class="keyword">val</span> int</span> : <code class="type">int <a href="Irmin.Merge.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">int</code> is the default merge function for integers.<br>
</div>

<pre><span id="VALint32"><span class="keyword">val</span> int32</span> : <code class="type">int32 <a href="Irmin.Merge.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">int32</code> is the default merge function for 32-bits integers.<br>
</div>

<pre><span id="VALint64"><span class="keyword">val</span> int64</span> : <code class="type">int64 <a href="Irmin.Merge.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">int64</code> the default merge function for 64-bit integers.<br>
</div>

<pre><span id="VALfloat"><span class="keyword">val</span> float</span> : <code class="type">float <a href="Irmin.Merge.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">float</code> is the default merge function for floating point
      numbers.<br>
</div>

<pre><span id="VALstring"><span class="keyword">val</span> string</span> : <code class="type">string <a href="Irmin.Merge.html#TYPEt">t</a></code></pre><div class="info ">
The default string merge function. Do not do anything clever, just
      compare the strings using the <code class="code">default</code> merge function.<br>
</div>

<pre><span id="VALoption"><span class="keyword">val</span> option</span> : <code class="type">'a <a href="Irmin.Merge.html#TYPEt">t</a> -> 'a option <a href="Irmin.Merge.html#TYPEt">t</a></code></pre><div class="info ">
Lift a merge function to optional values of the same type. If all
      the provided values are inhabited, then call the provided merge
      function, otherwise use the same behavior as <a href="Irmin.Merge.html#VALdefault"><code class="code"><span class="constructor">Irmin</span>.<span class="constructor">Merge</span>.default</code></a>.<br>
</div>

<pre><span id="VALpair"><span class="keyword">val</span> pair</span> : <code class="type">'a <a href="Irmin.Merge.html#TYPEt">t</a> -> 'b <a href="Irmin.Merge.html#TYPEt">t</a> -> ('a * 'b) <a href="Irmin.Merge.html#TYPEt">t</a></code></pre><div class="info ">
Lift merge functions to pair of elements.<br>
</div>

<pre><span id="VALtriple"><span class="keyword">val</span> triple</span> : <code class="type">'a <a href="Irmin.Merge.html#TYPEt">t</a> -><br>       'b <a href="Irmin.Merge.html#TYPEt">t</a> -> 'c <a href="Irmin.Merge.html#TYPEt">t</a> -> ('a * 'b * 'c) <a href="Irmin.Merge.html#TYPEt">t</a></code></pre><div class="info ">
Lift merge functions to triple of elements.<br>
</div>
<br>
<h1 id="1_CountersandMultisets">Counters and Multisets</h1><br>

<pre><span id="TYPEcounter"><span class="keyword">type</span> <code class="type"></code>counter</span> = <code class="type">int</code> </pre>
<div class="info ">
The type for counter values. It is expected that the only valid
      operations on counters are <em>increment</em> and <em>decrement</em>. The
      following merge functions ensure that the counter semantics are
      preserved: <em>i.e.</em> it ensures that the number of increments and
      decrements is preserved.<br>
</div>


<pre><span id="VALcounter"><span class="keyword">val</span> counter</span> : <code class="type">int <a href="Irmin.Merge.html#TYPEt">t</a></code></pre><div class="info ">
The merge function for mergeable counters.<br>
</div>

<pre><span class="keyword">module</span> <a href="Irmin.Merge.MultiSet.html">MultiSet</a>: <div class="sig_block"><code class="code"><span class="keyword">functor</span>&nbsp;(</code><code class="code"><span class="constructor">K</span></code><code class="code">&nbsp;:&nbsp;</code><code class="code"><span class="keyword">sig</span></code><div class="sig_block">
<pre><span class="keyword">include</span> Set.OrderedType</pre>

<pre><span id="VALt"><span class="keyword">val</span> t</span> : <code class="type"><a href="Irmin.Merge.html#TYPEt">Irmin.Merge.t</a> <a href="Irmin.Type.html#TYPEt">Irmin.Type.t</a></code></pre></div><code class="code"><span class="keyword">end</span></code><code class="code">)&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;</code><code class="code"><span class="keyword">sig</span></code> <a href="Irmin.Merge.MultiSet.html">..</a> <code class="code"><span class="keyword">end</span></code></div></pre><div class="info">
Multi-sets.
</div>
<br>
<h1 id="1_MapsandAssociationLists">Maps and Association Lists</h1><br>
<br>
We consider the only valid operations for maps and
      association lists to be:
<p>

      <ul>
<li>Adding a new bindings to the map.</li>
<li>Removing a binding from the map.</li>
<li>Replacing an existing binding with a different value.</li>
<li><em>Trying to add an already existing binding is a no-op</em>.</li>
</ul>

<p>

      We thus assume that no operation on maps is modifying the <em>      key</em> names. So the following merge functions ensures that <em>      (i)</em> new bindings are preserved <em>(ii)</em> removed bindings stay
      removed and <em>(iii)</em> modified bindings are merged using the
      merge function of values.
<p>

      <b>Note:</b> We only consider sets of bindings, instead of
      multisets. Application developers should take care of concurrent
      addition and removal of similar bindings themselves, by using the
      appropriate multi-sets.<br>

<pre><span class="keyword">module</span> <a href="Irmin.Merge.Set.html">Set</a>: <div class="sig_block"><code class="code"><span class="keyword">functor</span>&nbsp;(</code><code class="code"><span class="constructor">E</span></code><code class="code">&nbsp;:&nbsp;</code><code class="code"><span class="keyword">sig</span></code><div class="sig_block">
<pre><span class="keyword">include</span> Set.OrderedType</pre>

<pre><span id="VALt"><span class="keyword">val</span> t</span> : <code class="type"><a href="Irmin.Merge.html#TYPEt">Irmin.Merge.t</a> <a href="Irmin.Type.html#TYPEt">Irmin.Type.t</a></code></pre></div><code class="code"><span class="keyword">end</span></code><code class="code">)&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;</code><code class="code"><span class="keyword">sig</span></code> <a href="Irmin.Merge.Set.html">..</a> <code class="code"><span class="keyword">end</span></code></div></pre><div class="info">
Lift merge functions to sets.
</div>

<pre><span id="VALalist"><span class="keyword">val</span> alist</span> : <code class="type">'a <a href="Irmin.Type.html#TYPEt">Irmin.Type.t</a> -><br>       'b <a href="Irmin.Type.html#TYPEt">Irmin.Type.t</a> -><br>       ('a -> 'b option <a href="Irmin.Merge.html#TYPEt">t</a>) -> ('a * 'b) list <a href="Irmin.Merge.html#TYPEt">t</a></code></pre><div class="info ">
Lift the merge functions to association lists.<br>
</div>
<br>
Lift the merge functions to maps.<br>

<pre><span class="keyword">module</span> <a href="Irmin.Merge.Map.html">Map</a>: <div class="sig_block"><code class="code"><span class="keyword">functor</span>&nbsp;(</code><code class="code"><span class="constructor">K</span></code><code class="code">&nbsp;:&nbsp;</code><code class="code"><span class="keyword">sig</span></code><div class="sig_block">
<pre><span class="keyword">include</span> Map.OrderedType</pre>

<pre><span id="VALt"><span class="keyword">val</span> t</span> : <code class="type"><a href="Irmin.Merge.html#TYPEt">Irmin.Merge.t</a> <a href="Irmin.Type.html#TYPEt">Irmin.Type.t</a></code></pre></div><code class="code"><span class="keyword">end</span></code><code class="code">)&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;</code><code class="code"><span class="keyword">sig</span></code> <a href="Irmin.Merge.Map.html">..</a> <code class="code"><span class="keyword">end</span></code></div></pre>
<pre><span class="keyword">module</span> <a href="Irmin.Merge.Infix.html">Infix</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Irmin.Merge.Infix.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Infix operators for manipulating merge results and <a href="Irmin.Merge.html#VALpromise"><code class="code"><span class="constructor">Irmin</span>.<span class="constructor">Merge</span>.promise</code></a>s.
</div>

<pre><span id="VALconflict_t"><span class="keyword">val</span> conflict_t</span> : <code class="type"><a href="Irmin.Merge.html#TYPEconflict">conflict</a> <a href="Irmin.Type.html#TYPEt">Irmin.Type.t</a></code></pre><div class="info ">
<code class="code">conflict_t</code> is the value type for <a href="Irmin.Merge.html#VALconflict"><code class="code"><span class="constructor">Irmin</span>.<span class="constructor">Merge</span>.conflict</code></a>.<br>
</div>

<pre><span id="VALresult_t"><span class="keyword">val</span> result_t</span> : <code class="type">'a <a href="Irmin.Type.html#TYPEt">Irmin.Type.t</a> -> ('a, <a href="Irmin.Merge.html#TYPEconflict">conflict</a>) Result.result <a href="Irmin.Type.html#TYPEt">Irmin.Type.t</a></code></pre><div class="info ">
<code class="code">result_t</code> is the value type for merge results.<br>
</div>
</body></html>