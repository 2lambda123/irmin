<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type">
<link rel="Start" href="index.html">
<link rel="previous" href="Irmin.Task.html">
<link rel="next" href="Irmin.Path.html">
<link rel="Up" href="Irmin.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="Irmin" rel="Chapter" href="Irmin.html">
<link title="Irmin_mem" rel="Chapter" href="Irmin_mem.html">
<link title="Irmin_unix" rel="Chapter" href="Irmin_unix.html"><link title="Merge Results" rel="Section" href="#1_MergeResults">
<link title="Merge Combinators" rel="Section" href="#1_MergeCombinators">
<link title="Basic Merges" rel="Section" href="#1_BasicMerges">
<link title="Counters and Multisets" rel="Section" href="#1_CountersandMultisets">
<link title="Maps and Association Lists" rel="Section" href="#1_MapsandAssociationLists">
<link title="Maps and Association Lists" rel="Section" href="#1_MapsandAssociationLists">
<title>Irmin.Merge</title>
</head>
<body>
<div class="navbar"><a class="pre" href="Irmin.Task.html" title="Irmin.Task">Previous</a>
&nbsp;<a class="up" href="Irmin.html" title="Irmin">Up</a>
&nbsp;<a class="post" href="Irmin.Path.html" title="Irmin.Path">Next</a>
</div>
<h1>Module <a href="type_Irmin.Merge.html">Irmin.Merge</a></h1>

<pre><span class="keyword">module</span> Merge: <code class="code"><span class="keyword">sig</span></code> <a href="Irmin.Merge.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info module top">
<code class="code"><span class="constructor">Merge</span></code> provides functions to build custom 3-way merge operators
    for various user-defined contents.<br>
</div>
<hr width="100%">
<br>
<h1 id="1_MergeResults">Merge Results</h1><br>

<pre><span id="TYPEresult"><span class="keyword">type</span> <code class="type">'a</code> result</span> = <code class="type">[ `Conflict of string | `Ok of 'a ]</code> </pre>
<div class="info ">
Type for merge results.<br>
</div>


<pre><span class="keyword">module</span> <a href="Irmin.Merge.Result.html">Result</a>: <code class="type">Tc.S1</code><code class="type">  with type 'a t = 'a result</code></pre><div class="info">
Base functions on results.
</div>

<pre><span id="VALbind"><span class="keyword">val</span> bind</span> : <code class="type">'a <a href="Irmin.Merge.html#TYPEresult">result</a> Lwt.t -><br>       ('a -> 'b <a href="Irmin.Merge.html#TYPEresult">result</a> Lwt.t) -> 'b <a href="Irmin.Merge.html#TYPEresult">result</a> Lwt.t</code></pre><div class="info ">
Monadic bind for results.<br>
</div>

<pre><span id="EXCEPTIONConflict"><span class="keyword">exception</span> Conflict</span> <span class="keyword">of</span> <code class="type">string</code></pre>
<div class="info ">
Exception which might be raised when merging.<br>
</div>

<pre><span id="VALexn"><span class="keyword">val</span> exn</span> : <code class="type">'a <a href="Irmin.Merge.html#TYPEresult">result</a> -> 'a Lwt.t</code></pre><div class="info ">
Convert <code class="code"><span class="keywordsign">`</span><span class="constructor">Conflict</span></code> results to <code class="code"><span class="constructor">Conflict</span></code> exceptions.<br>
</div>
<br>
<h1 id="1_MergeCombinators">Merge Combinators</h1><br>

<pre><span id="TYPEpromise"><span class="keyword">type</span> <code class="type">'a</code> promise</span> = <code class="type">unit -> 'a option <a href="Irmin.Merge.html#TYPEresult">result</a> Lwt.t</code> </pre>
<div class="info ">
An <code class="code"><span class="keywordsign">'</span>a</code> promise is a function which, when called, will
      eventually return a value type of <code class="code"><span class="keywordsign">'</span>a</code>. A promise is an
      optional, lazy and non-blocking value.<br>
</div>


<pre><span id="VALpromise"><span class="keyword">val</span> promise</span> : <code class="type">'a -> 'a <a href="Irmin.Merge.html#TYPEpromise">promise</a></code></pre><div class="info ">
<code class="code">promise a</code> is the promise containing <code class="code">a</code>.<br>
</div>

<pre><span id="VALpromise_map"><span class="keyword">val</span> promise_map</span> : <code class="type">('a -> 'b) -> 'a <a href="Irmin.Merge.html#TYPEpromise">promise</a> -> 'b <a href="Irmin.Merge.html#TYPEpromise">promise</a></code></pre><div class="info ">
<code class="code">promise_map f a</code> is the promise containing <code class="code">f</code> applied to what
      is promised by <code class="code">a</code>.<br>
</div>

<pre><span id="VALpromise_bind"><span class="keyword">val</span> promise_bind</span> : <code class="type">'a <a href="Irmin.Merge.html#TYPEpromise">promise</a> -><br>       ('a -> 'b <a href="Irmin.Merge.html#TYPEpromise">promise</a>) -> 'b <a href="Irmin.Merge.html#TYPEpromise">promise</a></code></pre><div class="info ">
<code class="code">promise_bind a f</code> is the promise returned by <code class="code">f</code> applied to
      what is promised by <code class="code">a</code>.<br>
</div>

<pre><span id="TYPEt"><span class="keyword">type</span> <code class="type">'a</code> t</span> = <code class="type">old:'a <a href="Irmin.Merge.html#TYPEpromise">promise</a> -> 'a -> 'a -> 'a <a href="Irmin.Merge.html#TYPEresult">result</a> Lwt.t</code> </pre>
<div class="info ">
Signature of a merge function. <code class="code">old</code> is the value of the
      least-common ancestor.
<p>

      <pre class="verbatim">              /----&gt; t1 ----\
      ----&gt; old              |--&gt; result
              \----&gt; t2 ----/
     </pre><br>
</div>


<pre><span id="VALseq"><span class="keyword">val</span> seq</span> : <code class="type">'a <a href="Irmin.Merge.html#TYPEt">t</a> list -> 'a <a href="Irmin.Merge.html#TYPEt">t</a></code></pre><div class="info ">
Call the merge functions in sequence. Stop as soon as one is <em>      not</em> returning a conflict.<br>
</div>

<pre><span id="VALapply"><span class="keyword">val</span> apply</span> : <code class="type">('a -> 'b <a href="Irmin.Merge.html#TYPEt">t</a>) -> 'a -> 'b <a href="Irmin.Merge.html#TYPEt">t</a></code></pre><div class="info ">
The <code class="code">apply</code> combinator is useful to untie recursive loops when
      building a complex merge function.<br>
</div>

<pre><span id="VALbiject"><span class="keyword">val</span> biject</span> : <code class="type">'a Tc.t -> 'b <a href="Irmin.Merge.html#TYPEt">t</a> -> ('a -> 'b) -> ('b -> 'a) -> 'a <a href="Irmin.Merge.html#TYPEt">t</a></code></pre><div class="info ">
Use the merge function defined in another domain. If the
      converting functions raise any exception the merge is a
      conflict.<br>
</div>

<pre><span id="VALbiject'"><span class="keyword">val</span> biject'</span> : <code class="type">'a Tc.t -><br>       'b <a href="Irmin.Merge.html#TYPEt">t</a> -> ('a -> 'b Lwt.t) -> ('b -> 'a Lwt.t) -> 'a <a href="Irmin.Merge.html#TYPEt">t</a></code></pre><div class="info ">
Same as <a href="Irmin.Merge.html#VALbiject">biject</a> but with blocking domain
      converting functions.<br>
</div>
<br>
<h1 id="1_BasicMerges">Basic Merges</h1><br>

<pre><span id="VALdefault"><span class="keyword">val</span> default</span> : <code class="type">'a Tc.t -> 'a <a href="Irmin.Merge.html#TYPEt">t</a></code></pre><div class="info ">
Create a default merge function. This is a simple merge
      function which supports changes in one branch at a time:
<p>

      <ul>
<li>if <code class="code">t1=t2</code> then the result of the merge is <code class="code"><span class="keywordsign">`</span><span class="constructor">OK</span> t1</code>;</li>
<li>if <code class="code">t1=old</code> then the result of the merge is <code class="code"><span class="keywordsign">`</span><span class="constructor">OK</span> t2</code>;</li>
<li>if <code class="code">t2=old</code> then return <code class="code"><span class="keywordsign">`</span><span class="constructor">OK</span> t1</code>;</li>
<li>otherwise the result is <code class="code"><span class="keywordsign">`</span><span class="constructor">Conflict</span></code>.</li>
</ul>
<br>
</div>

<pre><span id="VALstring"><span class="keyword">val</span> string</span> : <code class="type">string <a href="Irmin.Merge.html#TYPEt">t</a></code></pre><div class="info ">
The default string merge function. Do not do anything clever, just
      compare the strings using the <code class="code">default</code> merge function.<br>
</div>

<pre><span id="VALoption"><span class="keyword">val</span> option</span> : <code class="type">'a Tc.t -> 'a <a href="Irmin.Merge.html#TYPEt">t</a> -> 'a option <a href="Irmin.Merge.html#TYPEt">t</a></code></pre><div class="info ">
Lift a merge function to optional values of the same type. If all
      the provided values are inhabited, then call the provided merge
      function, otherwise use the same behavior as <a href="Irmin.Merge.html#VALdefault"><code class="code"><span class="constructor">Irmin</span>.<span class="constructor">Merge</span>.default</code></a>.<br>
</div>

<pre><span id="VALpair"><span class="keyword">val</span> pair</span> : <code class="type">'a Tc.t -><br>       'b Tc.t -> 'a <a href="Irmin.Merge.html#TYPEt">t</a> -> 'b <a href="Irmin.Merge.html#TYPEt">t</a> -> ('a * 'b) <a href="Irmin.Merge.html#TYPEt">t</a></code></pre><div class="info ">
Lift merge functions to pair of elements.<br>
</div>

<pre><span id="VALtriple"><span class="keyword">val</span> triple</span> : <code class="type">'a Tc.t -><br>       'b Tc.t -><br>       'c Tc.t -><br>       'a <a href="Irmin.Merge.html#TYPEt">t</a> -><br>       'b <a href="Irmin.Merge.html#TYPEt">t</a> -> 'c <a href="Irmin.Merge.html#TYPEt">t</a> -> ('a * 'b * 'c) <a href="Irmin.Merge.html#TYPEt">t</a></code></pre><div class="info ">
Lift merge functions to triple of elements.<br>
</div>

<pre><span id="VALset"><span class="keyword">val</span> set</span> : <code class="type">(module Set.S with type t = 'a) -> 'a <a href="Irmin.Merge.html#TYPEt">t</a></code></pre><div class="info ">
List merge functions to sets.<br>
</div>
<br>
<h1 id="1_CountersandMultisets">Counters and Multisets</h1><br>

<pre><span id="TYPEcounter"><span class="keyword">type</span> <code class="type"></code>counter</span> = <code class="type">int</code> </pre>
<div class="info ">
The type for counter values. It is expected that the only valid
      operations on counters are <em>increment</em> and <em>decrement</em>. The
      following merge functions ensure that the counter semantics are
      preserved: <em>i.e.</em> it ensures that the number of increments and
      decrements is preserved.<br>
</div>


<pre><span id="VALcounter"><span class="keyword">val</span> counter</span> : <code class="type">int <a href="Irmin.Merge.html#TYPEt">t</a></code></pre><div class="info ">
The merge function for mergeable counters.<br>
</div>

<pre><span class="keyword">module</span> <a href="Irmin.Merge.MSet.html">MSet</a> <code class="code">(</code><code class="code"><span class="constructor">M</span></code><code class="code"> : </code><code class="type">Map.S</code><code class="code">) </code>: <code class="code"><span class="keyword">sig</span></code> <a href="Irmin.Merge.MSet.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Multi-sets.
</div>
<br>
<h1 id="1_MapsandAssociationLists">Maps and Association Lists</h1><br>
<br>
<h1 id="1_MapsandAssociationLists">Maps and Association Lists</h1><br>
<br>
We consider the only valid operations for maps and
      association lists to be:
<p>

      <ul>
<li>Adding a new bindings to the map.</li>
<li>Removing a binding from the map.</li>
<li>Replacing an existing binding with a different value.</li>
<li><em>Trying to add an already existing binding is a no-op</em>.</li>
</ul>

<p>

      We thus assume that no operation on maps is modifying the <em>      key</em> names. So the following merge functions ensures that <em>      (i)</em> new bindings are preserved <em>(ii)</em> removed bindings stay
      removed and <em>(iii)</em> modified bindings are merged using the
      merge function of values.
<p>

      <b>Note:</b> We only consider sets of bindings, instead of
      multisets. Application developers should take care of concurrent
      addition and removal of similar bindings themselves, by using the
      appropriate <a href="Irmin.Merge.MSet.html">multi-sets</a>.<br>

<pre><span id="VALalist"><span class="keyword">val</span> alist</span> : <code class="type">'a Tc.t -><br>       'b Tc.t -> ('a -> 'b option <a href="Irmin.Merge.html#TYPEt">t</a>) -> ('a * 'b) list <a href="Irmin.Merge.html#TYPEt">t</a></code></pre><div class="info ">
Lift the merge functions to association lists.<br>
</div>

<pre><span class="keyword">module</span> <a href="Irmin.Merge.Map.html">Map</a> <code class="code">(</code><code class="code"><span class="constructor">M</span></code><code class="code"> : </code><code class="type">Map.S</code><code class="code">) </code> <code class="code">(</code><code class="code"><span class="constructor">X</span></code><code class="code"> : </code><code class="type">Tc.S0</code><code class="type">  with type t = M.key</code><code class="code">) </code>: <code class="code"><span class="keyword">sig</span></code> <a href="Irmin.Merge.Map.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Lift the merge functions to maps.
</div>

<pre><span class="keyword">module</span> <a href="Irmin.Merge.OP.html">OP</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Irmin.Merge.OP.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Useful merge operators.
</div>
</body></html>