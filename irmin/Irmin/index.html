<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Irmin (irmin.Irmin)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.3"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">irmin</a> &#x00BB; Irmin</nav><h1>Module <code>Irmin</code></h1><p>Irmin public API.</p><p><code>Irmin</code> is a library to design and use persistent stores with built-in snapshot, branching and reverting mechanisms. Irmin uses concepts similar to <a href="http://git-scm.com/">Git</a> but it exposes them as a high level library instead of a complex command-line frontend. It features a <em>bidirectional</em> Git backend, where an application can read and persist its state using the Git format, fully-compatible with the usual Git tools and workflows.</p><p>Irmin is designed to use a large variety of backends. It is written in pure OCaml and does not depend on external C stubs; it is thus very portable and aims to run everywhere, from Linux to browser and MirageOS unikernels.</p><p>Consult the <code>basics</code> and <a href="index.html#examples"><span>Examples</span></a> of use for a quick start. See also the <span class="xref-unresolved" title="unresolved reference to &quot;Irmin_unix&quot;"><span>documentation</span></span> for the unix backends.</p><p><em>Release 3.0.0 - %%HOMEPAGE%%</em></p><nav class="toc"><ul><li><a href="#preliminaries">Preliminaries</a></li><li><a href="#low-level-stores">Low-level Stores</a></li><li><a href="#user-defined-contents">User-Defined Contents</a></li><li><a href="#high-level-stores">High-level Stores</a><ul><li><a href="#synchronization">Synchronization</a></li></ul></li><li><a href="#examples">Examples</a><ul><li><a href="#syncing-with-a-remote">Syncing with a remote</a></li><li><a href="#mergeable-logs">Mergeable logs</a></li></ul></li><li><a href="#helpers">Helpers</a></li><li><a href="#backend">Backends</a></li></ul></nav></header><dl><dt class="spec value" id="val-version"><a href="#val-version" class="anchor"></a><code><span class="keyword">val</span> version : string</code></dt><dd><p>The version of the library.</p></dd></dl><section><header><h2 id="preliminaries"><a href="#preliminaries" class="anchor"></a>Preliminaries</h2></header><dl><dt class="spec module" id="module-Type"><a href="#module-Type" class="anchor"></a><code><span class="keyword">module</span> Type = Repr</code></dt><dd><p>Dynamic types for Irmin values, supplied by <a href="https://github.com/mirage/repr"><code>Repr</code></a>. These values can be derived from type definitions via <code>[@@deriving irmin]</code> (see the <a href="https://github.com/mirage/irmin/blob/main/README_PPX.md">documentation for <code>ppx_irmin</code></a>)</p></dd></dl><dl><dt class="spec module" id="module-Info"><a href="#module-Info" class="anchor"></a><code><span class="keyword">module</span> <a href="Info/index.html">Info</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Commit info are used to keep track of the origin of write operations in the stores. <code>Info</code> models the metadata associated with commit objects in Git.</p></dd></dl><dl><dt class="spec module" id="module-Merge"><a href="#module-Merge" class="anchor"></a><code><span class="keyword">module</span> <a href="Merge/index.html">Merge</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p><code>Merge</code> provides functions to build custom 3-way merge operators for various user-defined contents.</p></dd></dl><dl><dt class="spec module" id="module-Diff"><a href="#module-Diff" class="anchor"></a><code><span class="keyword">module</span> <a href="Diff/index.html">Diff</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Differences between values.</p></dd></dl><dl><dt class="spec type" id="type-diff"><a href="#type-diff" class="anchor"></a><code><span class="keyword">type</span> <span>'a diff</span></code><code> = <span><span class="type-var">'a</span> <a href="Diff/index.html#type-t">Diff.t</a></span></code></dt><dd><p>The type for representing differences betwen values.</p></dd></dl><dl><dt class="spec module" id="module-Perms"><a href="#module-Perms" class="anchor"></a><code><span class="keyword">module</span> <a href="Perms/index.html">Perms</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Types representing <i>permissions</i> <code>'perms</code> for performing operations on a certain type <code>'perms t</code>.</p></dd></dl></section><section><header><h2 id="low-level-stores"><a href="#low-level-stores" class="anchor"></a>Low-level Stores</h2></header><aside><p>An Irmin store is automatically built from a number of lower-level stores, each implementing fewer operations, such as <span class="xref-unresolved" title="unresolved reference to &quot;Content_addressable.Store&quot;"><span>content-addressable</span></span> and <span class="xref-unresolved" title="unresolved reference to &quot;Atomic_write.Store&quot;"><span>atomic-write</span></span> stores. These low-level stores are provided by various backends.</p></aside><dl><dt class="spec module" id="module-Read_only"><a href="#module-Read_only" class="anchor"></a><code><span class="keyword">module</span> <a href="Read_only/index.html">Read_only</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Read-only backend backends.</p></dd></dl><dl><dt class="spec module" id="module-Append_only"><a href="#module-Append_only" class="anchor"></a><code><span class="keyword">module</span> <a href="Append_only/index.html">Append_only</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Append-only backend backends.</p></dd></dl><dl><dt class="spec module" id="module-Indexable"><a href="#module-Indexable" class="anchor"></a><code><span class="keyword">module</span> <a href="Indexable/index.html">Indexable</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Indexable backend backends.</p></dd></dl><dl><dt class="spec module" id="module-Content_addressable"><a href="#module-Content_addressable" class="anchor"></a><code><span class="keyword">module</span> <a href="Content_addressable/index.html">Content_addressable</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Content-addressable backends.</p></dd></dl><dl><dt class="spec module" id="module-Atomic_write"><a href="#module-Atomic_write" class="anchor"></a><code><span class="keyword">module</span> <a href="Atomic_write/index.html">Atomic_write</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Atomic-write stores.</p></dd></dl></section><section><header><h2 id="user-defined-contents"><a href="#user-defined-contents" class="anchor"></a>User-Defined Contents</h2></header><dl><dt class="spec module" id="module-Path"><a href="#module-Path" class="anchor"></a><code><span class="keyword">module</span> <a href="Path/index.html">Path</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Store paths.</p></dd></dl><dl><dt class="spec module" id="module-Hash"><a href="#module-Hash" class="anchor"></a><code><span class="keyword">module</span> <a href="Hash/index.html">Hash</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Hashing functions.</p></dd></dl><dl><dt class="spec module" id="module-Metadata"><a href="#module-Metadata" class="anchor"></a><code><span class="keyword">module</span> <a href="Metadata/index.html">Metadata</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p><code>Metadata</code> defines metadata that is attached to contents but stored in nodes. For instance, the Git backend uses this to indicate the type of file (normal, executable or symlink).</p></dd></dl><dl><dt class="spec module" id="module-Contents"><a href="#module-Contents" class="anchor"></a><code><span class="keyword">module</span> <a href="Contents/index.html">Contents</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p><code>Contents</code> specifies how user-defined contents need to be <em>serializable</em> and <em>mergeable</em>.</p></dd></dl><dl><dt class="spec module" id="module-Branch"><a href="#module-Branch" class="anchor"></a><code><span class="keyword">module</span> <a href="Branch/index.html">Branch</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>User-defined branches.</p></dd></dl><dl><dt class="spec module" id="module-Node"><a href="#module-Node" class="anchor"></a><code><span class="keyword">module</span> <a href="Node/index.html">Node</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p><code>Node</code> provides functions to describe the graph-like structured values.</p></dd></dl><dl><dt class="spec module" id="module-Commit"><a href="#module-Commit" class="anchor"></a><code><span class="keyword">module</span> <a href="Commit/index.html">Commit</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Commit values represent the store history.</p></dd></dl><dl><dt class="spec type" id="type-remote"><a href="#type-remote" class="anchor"></a><code><span class="keyword">type</span> remote</code><code> = <a href="../Irmin__/Remote/index.html#type-t">Irmin__.Remote.t</a></code><code> = </code><code>..</code></dt><dd><p>The type for remote stores.</p></dd></dl><dl><dt class="spec type" id="type-config"><a href="#type-config" class="anchor"></a><code><span class="keyword">type</span> config</code><code> = <a href="../Irmin__/Conf/index.html#type-t">Irmin__.Conf.t</a></code></dt><dd><p>The type for backend-specific configuration values.</p><p>Every backend has different configuration options, which are kept abstract to the user.</p></dd></dl><dl><dt class="spec module" id="module-Backend"><a href="#module-Backend" class="anchor"></a><code><span class="keyword">module</span> <a href="Backend/index.html">Backend</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p><code>Backend</code> defines functions only useful for creating new backends. If you are just using the library (and not developing a new backend), you should not use this module.</p></dd></dl><dl><dt class="spec module" id="module-Key"><a href="#module-Key" class="anchor"></a><code><span class="keyword">module</span> <a href="Key/index.html">Key</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Module types for <i>keys</i> into an arbitrary store.</p></dd></dl></section><section><header><h2 id="high-level-stores"><a href="#high-level-stores" class="anchor"></a>High-level Stores</h2><p>An Irmin store is a branch-consistent store where keys are lists of steps.</p><p>An example is a Git repository where keys are filenames, <em>i.e.</em> lists of <code>'/'</code>-separated strings. More complex examples are structured values, where steps might contain first-class field accessors and array offsets.</p><p>Irmin provides the following features:</p><ul><li>Support for fast clones, branches and merges, in a fashion very similar to Git.</li><li>Efficient staging areas for fast, transient, in-memory operations.</li><li>Fast <a href="Sync/index.html"><span>synchronization</span></a> primitives between remote stores, using native backend protocols (as the Git protocol) when available.</li></ul></header><dl><dt class="spec exception" id="exception-Closed"><a href="#exception-Closed" class="anchor"></a><code><span class="keyword">exception</span> </code><code><span class="exception">Closed</span></code></dt><dd><p>The exception raised when any operation is attempted on a closed store, except for <span class="xref-unresolved" title="unresolved reference to &quot;S.close&quot;"><a href="index.html#module-type-S"><code>S</code></a>.close</span>, which is idempotent.</p></dd></dl><dl><dt class="spec module-type" id="module-type-S"><a href="#module-type-S" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-S/index.html">S</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Irmin stores.</p></dd></dl><dl><dt class="spec module-type" id="module-type-KV"><a href="#module-type-KV" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-KV/index.html">KV</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p><code>KV</code> is similar to <a href="module-type-S/index.html"><code>S</code></a> but chooses sensible implementations for path and branch.</p></dd></dl><div class="spec module" id="module-Json_tree"><a href="#module-Json_tree" class="anchor"></a><code><span class="keyword">module</span> <a href="Json_tree/index.html">Json_tree</a> : <a href="../Irmin__/Store/index.html#module-type-Json_tree">Irmin__.Store.Json_tree</a></code></div><dl><dt class="spec module" id="module-Schema"><a href="#module-Schema" class="anchor"></a><code><span class="keyword">module</span> <a href="Schema/index.html">Schema</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Store schemas</p></dd></dl><dl><dt class="spec module-type" id="module-type-Maker"><a href="#module-type-Maker" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-Maker/index.html">Maker</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p><code>Maker</code> is the signature exposed by any backend providing <a href="module-type-S/index.html"><code>S</code></a> implementations. <code>M</code> is the implementation of user-defined metadata, <code>C</code> is the one for user-defined contents, <code>B</code> is the implementation for branches and <code>H</code> is the implementation for object (blobs, trees, commits) hashes. It does not use any native synchronization primitives.</p></dd></dl><dl><dt class="spec module-type" id="module-type-KV_maker"><a href="#module-type-KV_maker" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-KV_maker/index.html">KV_maker</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p><code>KV_maker</code> is like <a href="module-type-Maker/index.html"><code>Maker</code></a> but where everything except the contents is replaced by sensible default implementations.</p></dd></dl><dl><dt class="spec module" id="module-Generic_key"><a href="#module-Generic_key" class="anchor"></a><code><span class="keyword">module</span> <a href="Generic_key/index.html">Generic_key</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>&quot;Generic key&quot; stores are Irmin stores in which the backend may not be keyed directly by the hashes of stored values. See <a href="Key/index.html"><code>Key</code></a> for more details.</p></dd></dl><section><header><h3 id="synchronization"><a href="#synchronization" class="anchor"></a>Synchronization</h3></header><dl><dt class="spec value" id="val-remote_store"><a href="#val-remote_store" class="anchor"></a><code><span class="keyword">val</span> remote_store : <span>(<span class="keyword">module</span> <a href="Generic_key/module-type-S/index.html">Generic_key.S</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="Generic_key/module-type-S/index.html#type-t">t</a> = <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="index.html#type-remote">remote</a></code></dt><dd><p><code>remote_store t</code> is the remote corresponding to the local store <code>t</code>. Synchronization is done by importing and exporting store <span class="xref-unresolved" title="unresolved reference to &quot;BC.slice&quot;"><span>slices</span></span>, so this is usually much slower than native synchronization using <span class="xref-unresolved" title="unresolved reference to &quot;Store.remote&quot;"><code>Store</code>.remote</span> but it works for all backends.</p></dd></dl><dl><dt class="spec module" id="module-Sync"><a href="#module-Sync" class="anchor"></a><code><span class="keyword">module</span> <a href="Sync/index.html">Sync</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Remote synchronisation.</p></dd></dl></section></section><section><header><h2 id="examples"><a href="#examples" class="anchor"></a>Examples</h2><p>These examples are in the <code>examples</code> directory of the distribution.</p></header><section><header><h4 id="syncing-with-a-remote"><a href="#syncing-with-a-remote" class="anchor"></a>Syncing with a remote</h4><p>A simple synchronization example, using the <span class="xref-unresolved" title="unresolved reference to &quot;Irmin_unix.Git&quot;"><span>Git</span></span> backend and the <a href="Sync/index.html"><code>Sync</code></a> helpers. The code clones a fresh repository if the repository does not exist locally, otherwise it performs a fetch: in this case, only the missing contents are downloaded.</p><pre><code class="ml">open Lwt.Infix
module S = Irmin_unix.Git.FS.KV (Irmin.Contents.String)
module Sync = Irmin.Sync (S)

let config = Irmin_git.config &quot;/tmp/test&quot;

let upstream =
  if Array.length Sys.argv = 2 then
    Uri.of_string (Store.remote Sys.argv.(1))
  else (
    Printf.eprintf &quot;Usage: sync [uri]\n%!&quot;;
    exit 1)

let test () =
  S.Repo.v config &gt;&gt;= S.main &gt;&gt;= fun t -&gt;
  Sync.pull_exn t upstream `Set &gt;&gt;= fun () -&gt;
  S.get t [ &quot;README.md&quot; ] &gt;|= fun r -&gt; Printf.printf &quot;%s\n%!&quot; r

let () = Lwt_main.run (test ())</code></pre></header></section><section><header><h4 id="mergeable-logs"><a href="#mergeable-logs" class="anchor"></a>Mergeable logs</h4><p>The complete code for the following can be found in <code>examples/custom_merge.ml</code>.</p><p>We will demonstrate the use of custom merge operators by defining mergeable debug log files. We first define a log entry as a pair of a timestamp and a message, using the combinator exposed by <a href="Type/index.html"><code>Irmin.Type</code></a>:</p><pre><code class="ml">open Lwt.Infix
open Astring

let time = ref 0L
let failure fmt = Fmt.kstr failwith fmt

(* A log entry *)
module Entry : sig
  include Irmin.Type.S

  val v : string -&gt; t
  val timestamp : t -&gt; int64
end = struct
  type t = { timestamp : int64; message : string } [@@deriving irmin]

  let compare x y = Int64.compare x.timestamp y.timestamp

  let v message =
    time := Int64.add 1L !time;
    { timestamp = !time; message }

  let timestamp t = t.timestamp

  let pp ppf { timestamp; message } =
    Fmt.pf ppf &quot;%04Ld: %s&quot; timestamp message

  let of_string str =
    match String.cut ~sep:&quot;: &quot; str with
    | None -&gt; Error (`Msg (&quot;invalid entry: &quot; ^ str))
    | Some (x, message) -&gt; (
        try Ok { timestamp = Int64.of_string x; message }
        with Failure e -&gt; Error (`Msg e))

  let t = Irmin.Type.like ~pp ~of_string ~compare t
end</code></pre><p>A log file is a list of entries (one per line), ordered by decreasing order of timestamps. The 3-way <code>merge</code> operator for log files concatenates and sorts the new entries and prepend them to the common ancestor's ones.</p><pre><code class="ml">(* A log file *)
module Log : sig
  include Irmin.Contents.S

  val add : t -&gt; Entry.t -&gt; t
  val empty : t
end = struct
  type t = Entry.t list [@@deriving irmin]

  let empty = []
  let pp_entry = Irmin.Type.pp Entry.t
  let lines ppf l = List.iter (Fmt.pf ppf &quot;%a\n&quot; pp_entry) (List.rev l)

  let of_string str =
    let lines = String.cuts ~empty:false ~sep:&quot;\n&quot; str in
    try
      List.fold_left
        (fun acc l -&gt;
          match Irmin.Type.of_string Entry.t l with
          | Ok x -&gt; x :: acc
          | Error (`Msg e) -&gt; failwith e)
        [] lines
      |&gt; fun l -&gt; Ok l
    with Failure e -&gt; Error (`Msg e)

  let t = Irmin.Type.like ~pp:lines ~of_string t
  let timestamp = function [] -&gt; 0L | e :: _ -&gt; Entry.timestamp e

  let newer_than timestamp file =
    let rec aux acc = function
      | [] -&gt; List.rev acc
      | h :: _ when Entry.timestamp h &lt;= timestamp -&gt; List.rev acc
      | h :: t -&gt; aux (h :: acc) t
    in
    aux [] file

  let merge ~old t1 t2 =
    let open Irmin.Merge.Infix in
    old () &gt;&gt;=* fun old -&gt;
    let old = match old with None -&gt; [] | Some o -&gt; o in
    let ts = timestamp old in
    let t1 = newer_than ts t1 in
    let t2 = newer_than ts t2 in
    let t3 =
      List.sort (Irmin.Type.compare Entry.t) (List.rev_append t1 t2)
    in
    Irmin.Merge.ok (List.rev_append t3 old)

  let merge = Irmin.Merge.(option (v t merge))
  let add t e = e :: t
end</code></pre><p><b>Note:</b> The serialisation primitives used in that example are not very efficient in this case as they parse the file every time. For real usage, you would write buffered versions of <code>Log.pp</code> and <code>Log.of_string</code>.</p><p>To persist the log file on disk, we need to choose a backend. We show here how to use the on-disk <code>Git</code> backend on Unix.</p><pre><code class="ml">(* Build an Irmin store containing log files. *)
module Store = Irmin_unix.Git.FS.KV (Log)

(* Set-up the local configuration of the Git repository. *)
let config = Irmin_git.config ~bare:true Config.root

(* Convenient alias for the info function for commit messages *)
let info = Irmin_unix.info</code></pre><p>We can now define a toy example to use our mergeable log files.</p><pre><code class="ml">let log_file = [ &quot;local&quot;; &quot;debug&quot; ]

let all_logs t =
  Store.find t log_file &gt;|= function None -&gt; Log.empty | Some l -&gt; l

(** Persist a new entry in the log. Pretty inefficient as it reads/writes
    the whole file every time. *)
let log t fmt =
  Printf.ksprintf
    (fun message -&gt;
      all_logs t &gt;&gt;= fun logs -&gt;
      let logs = Log.add logs (Entry.v message) in
      Store.set_exn t ~info:(info &quot;Adding a new entry&quot;) log_file logs)
    fmt

let print_logs name t =
  all_logs t &gt;|= fun logs -&gt;
  Fmt.pr &quot;-----------\n%s:\n-----------\n%a%!&quot; name (Irmin.Type.pp Log.t)
    logs

let main () =
  Config.init ();
  Store.Repo.v config &gt;&gt;= fun repo -&gt;
  Store.main repo &gt;&gt;= fun t -&gt;
  (* populate the log with some random messages *)
  Lwt_list.iter_s
    (fun msg -&gt; log t &quot;This is my %s &quot; msg)
    [ &quot;first&quot;; &quot;second&quot;; &quot;third&quot; ]
  &gt;&gt;= fun () -&gt;
  Printf.printf &quot;%s\n\n&quot; what;
  print_logs &quot;lca&quot; t &gt;&gt;= fun () -&gt;
  Store.clone ~src:t ~dst:&quot;test&quot; &gt;&gt;= fun x -&gt;
  log x &quot;Adding new stuff to x&quot; &gt;&gt;= fun () -&gt;
  log x &quot;Adding more stuff to x&quot; &gt;&gt;= fun () -&gt;
  log x &quot;More. Stuff. To x.&quot; &gt;&gt;= fun () -&gt;
  print_logs &quot;branch 1&quot; x &gt;&gt;= fun () -&gt;
  log t &quot;I can add stuff on t also&quot; &gt;&gt;= fun () -&gt;
  log t &quot;Yes. On t!&quot; &gt;&gt;= fun () -&gt;
  print_logs &quot;branch 2&quot; t &gt;&gt;= fun () -&gt;
  Store.merge_into ~info:(info &quot;Merging x into t&quot;) x ~into:t &gt;&gt;= function
  | Ok () -&gt; print_logs &quot;merge&quot; t
  | Error _ -&gt; failwith &quot;conflict!&quot;

let () = Lwt_main.run (main ())</code></pre></header></section></section><section><header><h2 id="helpers"><a href="#helpers" class="anchor"></a>Helpers</h2></header><dl><dt class="spec module" id="module-Dot"><a href="#module-Dot" class="anchor"></a><code><span class="keyword">module</span> <a href="Dot/index.html">Dot</a> : <span class="keyword">functor</span> (<a href="Dot/argument-1-S/index.html">S</a> : <a href="Generic_key/index.html#module-type-S">Generic_key.S</a>) <span>&#45;&gt;</span> <a href="Dot/index.html#module-type-S">Dot.S</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="Dot/index.html#type-db">db</a> = <a href="Dot/argument-1-S/index.html#type-t">S.t</a></code></dt><dd><p><code>Dot</code> provides functions to export a store to the Graphviz `dot` format.</p></dd></dl></section><section><header><h2 id="backend"><a href="#backend" class="anchor"></a>Backends</h2><p>API to create new Irmin backends. A backend is an implementation exposing either a concrete implementation of <a href="module-type-S/index.html"><code>S</code></a> or a functor providing <a href="module-type-S/index.html"><code>S</code></a> once applied.</p><p>There are two ways to create a concrete <a href="module-type-S/index.html"><code>Irmin.S</code></a> implementation:</p><ul><li><code>Make</code> creates a store where all the objects are stored in the same store, using the same internal keys format and a custom binary format based on <a href="https://github.com/janestreet/bin_prot">bin_prot</a>, with no native synchronization primitives: it is usually what is needed to quickly create a new backend.</li><li><code>Make_ext</code> creates a store with a <em>deep</em> embedding of each of the internal stores into separate store, with total control over the binary format and using the native synchronization protocols when available.</li></ul></header><dl><dt class="spec module" id="module-Maker"><a href="#module-Maker" class="anchor"></a><code><span class="keyword">module</span> <a href="Maker/index.html">Maker</a> : <span class="keyword">functor</span> (<a href="Maker/argument-1-CA/index.html">CA</a> : <a href="Content_addressable/index.html#module-type-Maker">Content_addressable.Maker</a>) <span>&#45;&gt;</span> <span class="keyword">functor</span> (<a href="Maker/argument-2-AW/index.html">AW</a> : <a href="Atomic_write/index.html#module-type-Maker">Atomic_write.Maker</a>) <span>&#45;&gt;</span> <a href="index.html#module-type-Maker">Maker</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="Maker/index.html#type-endpoint">endpoint</a> = unit</code></dt><dd><p>Simple store creator. Use the same type of all of the internal keys and store all the values in the same store.</p></dd></dl><div class="spec module" id="module-KV_maker"><a href="#module-KV_maker" class="anchor"></a><code><span class="keyword">module</span> <a href="KV_maker/index.html">KV_maker</a> : <span class="keyword">functor</span> (<a href="KV_maker/argument-1-CA/index.html">CA</a> : <a href="Content_addressable/index.html#module-type-Maker">Content_addressable.Maker</a>) <span>&#45;&gt;</span> <span class="keyword">functor</span> (<a href="KV_maker/argument-2-AW/index.html">AW</a> : <a href="Atomic_write/index.html#module-type-Maker">Atomic_write.Maker</a>) <span>&#45;&gt;</span> <a href="index.html#module-type-KV_maker">KV_maker</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="KV_maker/index.html#type-endpoint">endpoint</a> = unit <span class="keyword">and</span> <span class="keyword">type</span> <a href="KV_maker/index.html#type-metadata">metadata</a> = unit</code></div><dl><dt class="spec module" id="module-Of_backend"><a href="#module-Of_backend" class="anchor"></a><code><span class="keyword">module</span> <a href="Of_backend/index.html">Of_backend</a> : <span class="keyword">functor</span> (<a href="Of_backend/argument-1-B/index.html">B</a> : <a href="Backend/index.html#module-type-S">Backend.S</a>) <span>&#45;&gt;</span> <a href="Generic_key/index.html#module-type-S">Generic_key.S</a> <span class="keyword">with</span> <span class="keyword">module</span> <a href="Of_backend/Schema/index.html">Schema</a> = <a href="Of_backend/argument-1-B/index.html#module-Schema">B.Schema</a> <span class="keyword">and</span> <span class="keyword">type</span> <a href="Of_backend/index.html#type-repo">repo</a> = <a href="Of_backend/argument-1-B/Repo/index.html#type-t">B.Repo.t</a> <span class="keyword">and</span> <span class="keyword">type</span> <a href="Of_backend/index.html#type-slice">slice</a> = <a href="Of_backend/argument-1-B/Slice/index.html#type-t">B.Slice.t</a> <span class="keyword">and</span> <span class="keyword">type</span> <a href="Of_backend/index.html#type-contents_key">contents_key</a> = <a href="Of_backend/argument-1-B/Contents/Key/index.html#type-t">B.Contents.Key.t</a> <span class="keyword">and</span> <span class="keyword">type</span> <a href="Of_backend/index.html#type-node_key">node_key</a> = <a href="Of_backend/argument-1-B/Node/Key/index.html#type-t">B.Node.Key.t</a> <span class="keyword">and</span> <span class="keyword">type</span> <a href="Of_backend/index.html#type-commit_key">commit_key</a> = <a href="Of_backend/argument-1-B/Commit/Key/index.html#type-t">B.Commit.Key.t</a> <span class="keyword">and</span> <span class="keyword">module</span> <a href="Of_backend/Backend/index.html">Backend</a> = <a href="Of_backend/index.html#argument-1-B">B</a></code></dt><dd><p>Advanced store creator.</p></dd></dl><dl><dt class="spec module" id="module-Export_for_backends"><a href="#module-Export_for_backends" class="anchor"></a><code><span class="keyword">module</span> <a href="Export_for_backends/index.html">Export_for_backends</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Helper module containing useful top-level types for defining Irmin backends. This module is relatively unstable.</p></dd></dl></section></div></body></html>