<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type">
<link rel="Start" href="index.html">
<link rel="previous" href="Irmin.HRW.html">
<link rel="next" href="Irmin.S.html">
<link rel="Up" href="Irmin.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="Irmin" rel="Chapter" href="Irmin.html">
<link title="Irmin_mem" rel="Chapter" href="Irmin_mem.html">
<link title="Irmin_unix" rel="Chapter" href="Irmin_unix.html"><link title="Branch-consistent Store" rel="Section" href="#1_BranchconsistentStore">
<link title="Persistent Branches" rel="Subsection" href="#persistent">
<link title="Temporary Branches" rel="Subsection" href="#temporary">
<link title="Clones and Merges" rel="Subsection" href="#2_ClonesandMerges">
<link title="Slices" rel="Subsection" href="#2_Slices">
<title>Irmin.BC</title>
</head>
<body>
<div class="navbar"><a class="pre" href="Irmin.HRW.html" title="Irmin.HRW">Previous</a>
&nbsp;<a class="up" href="Irmin.html" title="Irmin">Up</a>
&nbsp;<a class="post" href="Irmin.S.html" title="Irmin.S">Next</a>
</div>
<h1>Module type <a href="type_Irmin.BC.html">Irmin.BC</a></h1>

<pre><span class="keyword">module type</span> BC = <code class="code"><span class="keyword">sig</span></code> <a href="Irmin.BC.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info modtype top">
Branch-consistent stores.<br>
</div>
<hr width="100%">
<br>
<h1 id="1_BranchconsistentStore">Branch-consistent Store</h1>
<p>

      Branch-consistent stores are hierarchical read-write stores with
      extended capabilities. They allow an application (or a
      collection of applications) to work with multiple local states,
      which can be forked and merged programmatically, whithout having
      to rely on a global state. In a way very similar to version
      control systems, Irmin local states are called <i>branches</i>.
<p>

      They are two kinds of branches in Irmin: the
      <a href="Irmin.BC.html#persistent">persistent</a> branches and the
      <a href="Irmin.BC.html#temporary">temporary</a> ones. Branches exists relatively to a
      local, larger (and shared) store, and have some (shared)
      contents. This is exactly the same as usual version control
      systems, that the informed user can see as an implicit purely
      functional data-structure.
<p>

      <h2 id="persistent">Persistent Branches</h2>
<p>

      A persistent branch always has a name. In Irmin, branch names
      are called <a href="Irmin.BC.html#VALtag">tags</a>. Thus, in order to use a persistent
      branch, you need to provide its name: see the <a href="Irmin.BC.html#VALof_tag">of_tag</a>
      function.<br>

<pre><span class="keyword">include</span> <a href="Irmin.HRW.html">Irmin.HRW</a></pre>
<br>
A branch-consistent store is a hierarchical read-write store.
<p>

      <code class="code">create config task</code> is a persistent branch using the
       branch. This operation is cheap, can be repeated
      multiple times.<br>

<pre><span id="TYPEtag"><span class="keyword">type</span> <code class="type"></code>tag</span> </pre>
<div class="info ">
Type for persistent branch names. Tags usually share a common
      global namespace and that's the user responsibility to avoid
      name-clashes.<br>
</div>


<pre><span id="VALof_tag"><span class="keyword">val</span> of_tag</span> : <code class="type"><a href="Irmin.html#TYPEconfig">Irmin.config</a> -> ('a -> <a href="Irmin.html#TYPEtask">Irmin.task</a>) -> <a href="Irmin.BC.html#TYPEtag">tag</a> -> ('a -> t) Lwt.t</code></pre><div class="info ">
<code class="code">create t tag</code> is the persistent branch named <code class="code">tag</code>. Similar to
      <code class="code">create</code>, but use <code class="code">tag</code> instead <a href="Irmin.Tag.S.html#VALmaster"><code class="code"><span class="constructor">Irmin</span>.<span class="constructor">Tag</span>.<span class="constructor">S</span>.master</code></a>.<br>
</div>

<pre><span id="VALtag"><span class="keyword">val</span> tag</span> : <code class="type">t -> <a href="Irmin.BC.html#TYPEtag">tag</a> option</code></pre><div class="info ">
<code class="code">tag t</code> is <code class="code">t</code>'s name. Return <code class="code"><span class="constructor">None</span></code> if <code class="code">t</code> is not
      persistent.<br>
</div>

<pre><span id="VALtag_exn"><span class="keyword">val</span> tag_exn</span> : <code class="type">t -> <a href="Irmin.BC.html#TYPEtag">tag</a></code></pre><div class="info ">
Same as <code class="code">tag</code> but raise <code class="code"><span class="constructor">Not_found</span></code> if <code class="code">t</code> is not persistent.<br>
</div>

<pre><span id="VALtags"><span class="keyword">val</span> tags</span> : <code class="type">t -> <a href="Irmin.BC.html#TYPEtag">tag</a> list Lwt.t</code></pre><div class="info ">
The list of all persistent branch 's names. Similar to to <i>git
      branch -a</i>.<br>
</div>

<pre><span id="VALremove_tag"><span class="keyword">val</span> remove_tag</span> : <code class="type">t -> unit Lwt.t</code></pre><div class="info ">
<code class="code">remove_tag t</code> removes <code class="code">t</code>'s name from the local store. Do
      nothing if <code class="code">t</code> is not persistent. Similar to <i>git branch -D
      &lt;current-branch&gt;</i><br>
</div>

<pre><span id="VALrename_tag"><span class="keyword">val</span> rename_tag</span> : <code class="type">t -> <a href="Irmin.BC.html#TYPEtag">tag</a> -> [ `Duplicated_tag | `Ok ] Lwt.t</code></pre><div class="info ">
<code class="code">rename_tag t tag</code> renames the branch <code class="code">t</code> to <code class="code">tag</code>, without
      changing its contents. Fail if a branch with the same name
      already exists. Similar to <i>git branch -M &lt;tag&gt;</i>.<br>
</div>

<pre><span id="VALupdate_tag"><span class="keyword">val</span> update_tag</span> : <code class="type">t -> <a href="Irmin.BC.html#TYPEtag">tag</a> -> unit Lwt.t</code></pre><div class="info ">
<code class="code">update_tag t tag</code> updates <code class="code">t</code>'s contents with the contents of
      the branch named <code class="code">tag</code>. Can cause data losses as it discard the
      current contents. Similar to <i>git reset --hard &lt;tag&gt;</i>.<br>
</div>

<pre><span id="VALmerge_tag"><span class="keyword">val</span> merge_tag</span> : <code class="type">t -><br>       ?max_depth:int -> ?n:int -> <a href="Irmin.BC.html#TYPEtag">tag</a> -> unit <a href="Irmin.Merge.html#TYPEresult">Irmin.Merge.result</a> Lwt.t</code></pre><div class="info ">
<code class="code">merge_tag t tag</code> merges the contents of the branch named <code class="code">tag</code>
      into <code class="code">t</code>'s. Similar to <i>git merge &lt;tag&gt;</i>.<br>
</div>

<pre><span id="VALmerge_tag_exn"><span class="keyword">val</span> merge_tag_exn</span> : <code class="type">t -> ?max_depth:int -> ?n:int -> <a href="Irmin.BC.html#TYPEtag">tag</a> -> unit Lwt.t</code></pre><div class="info ">
Same as <a href="Irmin.BC.html#VALmerge_tag"><code class="code"><span class="constructor">Irmin</span>.<span class="constructor">BC</span>.merge_tag</code></a> but raise <a href="Irmin.Merge.html#EXCEPTIONConflict"><code class="code"><span class="constructor">Irmin</span>.<span class="constructor">Merge</span>.<span class="constructor">Conflict</span></code></a> in case of
      conflict.<br>
</div>

<pre><span id="VALswitch_tag"><span class="keyword">val</span> switch_tag</span> : <code class="type">t -> <a href="Irmin.BC.html#TYPEtag">tag</a> -> unit Lwt.t</code></pre><div class="info ">
<code class="code">switch_tag t tag</code> switches the current branch name to be <code class="code">tag</code>
      and the contents of the current branch to be <code class="code">tag</code>'s
      contents. If <code class="code">tag</code> does not exit, create a new branch
      name. Similar to <i>git checkout <code class="code">-b</code> &lt;tag&gt;</i>.<br>
</div>
<br>
<h2 id="temporary">Temporary Branches</h2>
<p>

      Temporary branches do not have stable names: instead they can be
      adressed using the hash of the current commit. These hashes are
      called <a href="Irmin.BC.html#VALhead">heads</a> in Irmin. Temporary branches are
      similar to Git's detached heads. In a temporary branch, all the
      operations are done relatively to the current head and update
      operations can modify the current head: the branch current's
      head will automatically become the new head obtained while
      performing the update.
<p>

      Temporary branches are created using the <a href="Irmin.BC.html#VALof_head"><code class="code"><span class="constructor">Irmin</span>.<span class="constructor">BC</span>.of_head</code></a>
      function.<br>

<pre><span id="TYPEhead"><span class="keyword">type</span> <code class="type"></code>head</span> </pre>
<div class="info ">
Type for temporary branches names. Similar to Git's commit
      SHA1s.<br>
</div>


<pre><span id="VALof_head"><span class="keyword">val</span> of_head</span> : <code class="type"><a href="Irmin.html#TYPEconfig">Irmin.config</a> -> ('a -> <a href="Irmin.html#TYPEtask">Irmin.task</a>) -> <a href="Irmin.BC.html#TYPEhead">head</a> -> ('a -> t) Lwt.t</code></pre><div class="info ">
Create a temporary branch, using the given <code class="code">head</code>. The branch
      will not persist as it has no persistent branch name.<br>
</div>

<pre><span id="VALhead"><span class="keyword">val</span> head</span> : <code class="type">t -> <a href="Irmin.BC.html#TYPEhead">head</a> option Lwt.t</code></pre><div class="info ">
<code class="code">head t</code> is the current head of the branch <code class="code">t</code>. This works for
      both persistent and temporary branches. In the case of a
      persistent branch, this involves getting the the head associated
      with the branch's tag, so this might blocks. In the case of a
      temporary branch, simply return the current branch head. Return
      <code class="code"><span class="constructor">None</span></code> is the branch has no contents. Similar to <i>git
      rev-parse HEAD</i>.<br>
</div>

<pre><span id="VALhead_exn"><span class="keyword">val</span> head_exn</span> : <code class="type">t -> <a href="Irmin.BC.html#TYPEhead">head</a> Lwt.t</code></pre><div class="info ">
Same as <code class="code">read_head</code> but raise <code class="code"><span class="constructor">Not_found</span></code> if the branch does not
      have any contents.<br>
</div>

<pre><span id="VALbranch"><span class="keyword">val</span> branch</span> : <code class="type">t -> [ `Head of <a href="Irmin.BC.html#TYPEhead">head</a> | `Tag of <a href="Irmin.BC.html#TYPEtag">tag</a> ]</code></pre><div class="info ">
<code class="code">branch t</code> is a representation of <code class="code">t</code>'s branch. Can either be a
      persistent branch with a <code class="code">tag</code> name or a temporary branch with a
      <code class="code">head</code> commit.<br>
</div>

<pre><span id="VALheads"><span class="keyword">val</span> heads</span> : <code class="type">t -> <a href="Irmin.BC.html#TYPEhead">head</a> list Lwt.t</code></pre><div class="info ">
<code class="code">heads t</code> is the list of all the heads in <code class="code">t</code>'s store. Similar
      to <i>git rev-list --all</i>.<br>
</div>

<pre><span id="VALdetach"><span class="keyword">val</span> detach</span> : <code class="type">t -> unit Lwt.t</code></pre><div class="info ">
<code class="code">detach t</code> transform the persistent branch <code class="code">t</code> into a temporary
      branch with the same contents. Do nothing if the branch is
      already a temporary one. Similar to <i>git checkout --detach
      &lt;current-tag&gt;</i>.<br>
</div>

<pre><span id="VALupdate_head"><span class="keyword">val</span> update_head</span> : <code class="type">t -> <a href="Irmin.BC.html#TYPEhead">head</a> -> unit Lwt.t</code></pre><div class="info ">
<code class="code">update_head t h</code> updates <code class="code">t</code>'s contents with the contents of
      the head <code class="code">h</code>. Can cause data losses as it discards the current
      contents. Similar to <i>git reset --hard &lt;SHA1&gt;</i>.<br>
</div>

<pre><span id="VALmerge_head"><span class="keyword">val</span> merge_head</span> : <code class="type">t -><br>       ?max_depth:int -> ?n:int -> <a href="Irmin.BC.html#TYPEhead">head</a> -> unit <a href="Irmin.Merge.html#TYPEresult">Irmin.Merge.result</a> Lwt.t</code></pre><div class="info ">
<code class="code">merge_head t ?max_head ?n head</code> merges the contents of the
      temporary branch associated to <code class="code">head</code> into <code class="code">t</code>. <code class="code">max_depth</code> is
      the maximal depth used for getting the lowest common
      ancestor. <code class="code">n</code> is the maximum number of lowest common
      ancestors. Both <code class="code">max_depth</code> and <code class="code">n</code> are used to drive the common
      ancestor exploration when the user knows about the history's
      partial-order shape.<br>
</div>

<pre><span id="VALmerge_head_exn"><span class="keyword">val</span> merge_head_exn</span> : <code class="type">t -> ?max_depth:int -> ?n:int -> <a href="Irmin.BC.html#TYPEhead">head</a> -> unit Lwt.t</code></pre><div class="info ">
Same as <a href="Irmin.BC.html#VALmerge_head">merge_head</a> but raise <a href="Irmin.Merge.html#EXCEPTIONConflict"><code class="code"><span class="constructor">Irmin</span>.<span class="constructor">Merge</span>.<span class="constructor">Conflict</span></code></a>
      in case of a conflict.<br>
</div>

<pre><span id="VALswitch_head"><span class="keyword">val</span> switch_head</span> : <code class="type">t -> <a href="Irmin.BC.html#TYPEhead">head</a> -> unit Lwt.t</code></pre><div class="info ">
<code class="code">switch t h</code> changes <code class="code">t</code>'s head to be <code class="code">h</code>. Similar to <i>git
      checkout &lt;sha1&gt;</i>.<br>
</div>

<pre><span id="VALwatch_head"><span class="keyword">val</span> watch_head</span> : <code class="type">t -> key -> (key * <a href="Irmin.BC.html#TYPEhead">head</a> option) Lwt_stream.t</code></pre><div class="info ">
FIXME Watch changes for a given collection of keys and the ones they
      have recursive access. Return the stream of heads corresponding
      to the modified keys.<br>
</div>

<pre><span id="VALwatch_tags"><span class="keyword">val</span> watch_tags</span> : <code class="type">t -> (<a href="Irmin.BC.html#TYPEtag">tag</a> * <a href="Irmin.BC.html#TYPEhead">head</a> option) Lwt_stream.t</code></pre><div class="info ">
FIXME Watch for creation and deletion of tags.<br>
</div>
<br>
<h2 id="2_ClonesandMerges">Clones and Merges</h2><br>

<pre><span id="VALclone"><span class="keyword">val</span> clone</span> : <code class="type">('a -> <a href="Irmin.html#TYPEtask">Irmin.task</a>) -><br>       t -> <a href="Irmin.BC.html#TYPEtag">tag</a> -> [ `Duplicated_tag | `Ok of 'a -> t ] Lwt.t</code></pre><div class="info ">
Clone the store <code class="code">t</code>, using the given branch name. Return <code class="code"><span class="constructor">None</span></code>
      if a branch with the same name already exists.<br>
</div>

<pre><span id="VALclone_force"><span class="keyword">val</span> clone_force</span> : <code class="type">('a -> <a href="Irmin.html#TYPEtask">Irmin.task</a>) -> t -> <a href="Irmin.BC.html#TYPEtag">tag</a> -> ('a -> t) Lwt.t</code></pre><div class="info ">
Same as <a href="Irmin.BC.html#VALclone">clone</a> but delete and update the existing
      branch if a branch with the same name already exists.<br>
</div>

<pre><span id="VALmerge"><span class="keyword">val</span> merge</span> : <code class="type">'a -><br>       ?max_depth:int -><br>       ?n:int -> ('a -> t) -> into:('a -> t) -> unit <a href="Irmin.Merge.html#TYPEresult">Irmin.Merge.result</a> Lwt.t</code></pre><div class="info ">
<code class="code">merge x t i</code> merges <code class="code">t x</code>'s current branch into <code class="code">i x</code>'s current
      branch. After that operation, the two stores are still
      independent. Similar to <i>git merge</i>.<br>
</div>

<pre><span id="VALmerge_exn"><span class="keyword">val</span> merge_exn</span> : <code class="type">'a -> ?max_depth:int -> ?n:int -> ('a -> t) -> into:('a -> t) -> unit Lwt.t</code></pre><div class="info ">
FIXME Same as <a href="Irmin.BC.html#VALmerge">merge</a> but raise <a href="Irmin.Merge.html#EXCEPTIONConflict"><code class="code"><span class="constructor">Irmin</span>.<span class="constructor">Merge</span>.<span class="constructor">Conflict</span></code></a> in case
      of a conflict.<br>
</div>

<pre><span id="VALlcas"><span class="keyword">val</span> lcas</span> : <code class="type">'a -><br>       ?max_depth:int -><br>       ?n:int -><br>       ('a -> t) -><br>       ('a -> t) -><br>       [ `Max_depth_reached | `Ok of <a href="Irmin.BC.html#TYPEhead">head</a> list | `Too_many_lcas ] Lwt.t</code></pre><div class="info ">
<code class="code">lca ?max_depth ?n msg t1 t2</code> returns the collection of least
      common ancestors between the heads of <code class="code">t1</code> and <code class="code">t2</code> branches.
<p>

      <ul>
<li><code class="code">max_depth</code> is the maximum depth of the exploration (default
      is 250). Return <code class="code"><span class="keywordsign">`</span><span class="constructor">Max_depth_reached</span></code> is this depth is exceeded.</li>
<li><code class="code">n</code> is the maximum expected number of lcas. Stop the
      exploration as soon as <code class="code">n</code> lcas are found. Return
      <code class="code"><span class="keywordsign">`</span><span class="constructor">Too_many_lcas</span></code> if more <code class="code">lcas</code> are found. </li>
</ul>
<br>
</div>

<pre><span id="VALlcas_tag"><span class="keyword">val</span> lcas_tag</span> : <code class="type">t -><br>       ?max_depth:int -><br>       ?n:int -><br>       <a href="Irmin.BC.html#TYPEtag">tag</a> -><br>       [ `Max_depth_reached | `Ok of <a href="Irmin.BC.html#TYPEhead">head</a> list | `Too_many_lcas ] Lwt.t</code></pre><div class="info ">
Same as <a href="Irmin.BC.html#VALlcas"><code class="code"><span class="constructor">Irmin</span>.<span class="constructor">BC</span>.lcas</code></a> but takes a tag as argument.<br>
</div>

<pre><span id="VALlcas_head"><span class="keyword">val</span> lcas_head</span> : <code class="type">t -><br>       ?max_depth:int -><br>       ?n:int -><br>       <a href="Irmin.BC.html#TYPEhead">head</a> -><br>       [ `Max_depth_reached | `Ok of <a href="Irmin.BC.html#TYPEhead">head</a> list | `Too_many_lcas ] Lwt.t</code></pre><div class="info ">
Same as <a href="Irmin.BC.html#VALlcas"><code class="code"><span class="constructor">Irmin</span>.<span class="constructor">BC</span>.lcas</code></a> but takes an head as argument.<br>
</div>

<pre><span id="VALtask_of_head"><span class="keyword">val</span> task_of_head</span> : <code class="type">t -> <a href="Irmin.BC.html#TYPEhead">head</a> -> <a href="Irmin.html#TYPEtask">Irmin.task</a> Lwt.t</code></pre><div class="info ">
<code class="code">task_of_head t h</code> is the task which created <code class="code">h</code>. Useful to
      retrieve the commit date and the committer name.<br>
</div>
<br>
<h2 id="2_Slices">Slices</h2><br>

<pre><span id="TYPEslice"><span class="keyword">type</span> <code class="type"></code>slice</span> </pre>
<div class="info ">
Type for store slices.<br>
</div>


<pre><span id="VALexport"><span class="keyword">val</span> export</span> : <code class="type">?full:bool -><br>       ?depth:int -><br>       ?min:<a href="Irmin.BC.html#TYPEhead">head</a> list -><br>       ?max:<a href="Irmin.BC.html#TYPEhead">head</a> list -> t -> <a href="Irmin.BC.html#TYPEslice">slice</a> Lwt.t</code></pre><div class="info ">
<code class="code">export t ~depth ~min ~max</code> exports the store slice between
      <code class="code">min</code> and <code class="code">max</code>, using at most <code class="code">depth</code> history depth (starting
      from the max).
<p>

      If <code class="code">max</code> is not specified, use the current <code class="code">heads</code>. If <code class="code">min</code> is
      not specified, use an unbound past (but can be still limited by
      <code class="code">depth</code>).
<p>

      <code class="code">depth</code> is used to limit the depth of the commit history. <code class="code"><span class="constructor">None</span></code>
      here means no limitation.
<p>

      If <code class="code">full</code> is set (default is true) the full graph, including the
      commits, nodes and contents, is exported, otherwise it is the
      commit history graph only.<br>
</div>

<pre><span id="VALimport"><span class="keyword">val</span> import</span> : <code class="type">t -> <a href="Irmin.BC.html#TYPEslice">slice</a> -> unit Lwt.t</code></pre><div class="info ">
<code class="code">import t s</code> imports the contents of the slice <code class="code">s</code> in <code class="code">t</code>. Do
      not modify tags.<br>
</div>
</body></html>