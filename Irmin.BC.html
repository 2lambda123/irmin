<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=utf-8" http-equiv="Content-Type">
<link rel="Start" href="index.html">
<link rel="previous" href="Irmin.RRW.html">
<link rel="next" href="Irmin.S.html">
<link rel="Up" href="Irmin.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="Irmin" rel="Chapter" href="Irmin.html">
<link title="Irmin_mem" rel="Chapter" href="Irmin_mem.html">
<link title="Irmin_git" rel="Chapter" href="Irmin_git.html">
<link title="Irmin_fs" rel="Chapter" href="Irmin_fs.html">
<link title="Irmin_http" rel="Chapter" href="Irmin_http.html">
<link title="Irmin_http_server" rel="Chapter" href="Irmin_http_server.html">
<link title="Irmin_unix" rel="Chapter" href="Irmin_unix.html"><link title="Branch-consistent stores" rel="Section" href="#1_Branchconsistentstores">
<link title="Persistent Branches" rel="Subsection" href="#persistent">
<link title="Temporary Stores" rel="Subsection" href="#temporary">
<link title="Clones and Merges" rel="Subsection" href="#2_ClonesandMerges">
<link title="History" rel="Subsection" href="#2_History">
<title>Irmin.BC</title>
</head>
<body>
<div class="navbar"><a class="pre" href="Irmin.RRW.html" title="Irmin.RRW">Previous</a>
&nbsp;<a class="up" href="Irmin.html" title="Irmin">Up</a>
&nbsp;<a class="post" href="Irmin.S.html" title="Irmin.S">Next</a>
</div>
<h1>Module type <a href="type_Irmin.BC.html">Irmin.BC</a></h1>

<pre><span class="keyword">module type</span> BC = <code class="code"><span class="keyword">sig</span></code> <a href="Irmin.BC.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info modtype top">
Branch-consistent stores.<br>
</div>
<hr width="100%">
<br>
<h1 id="1_Branchconsistentstores">Branch-consistent stores</h1>
<p>

      Branch-consistent stores are hierarchical read-write stores with
      extended capabilities. They allow an application (or a
      collection of applications) to work with multiple local states,
      which can be forked and merged programmatically, without having
      to rely on a global state. In a way very similar to version
      control systems, Irmin local states are called <i>branches</i>.
<p>

      There are two kinds of BC store in Irmin:
      <a href="Irmin.BC.html#persistent">persistent</a> named branches and
      <a href="Irmin.BC.html#temporary">temporary</a> detached heads. These exist relative to a
      local, larger (and shared) store, and have some (shared)
      contents. This is exactly the same as usual version control
      systems, that the informed user can see as an implicit purely
      functional data-structure.
<p>

      <h2 id="persistent">Persistent Branches</h2>
<p>

      A persistent branch always has a unique ID, which is typically a
      string (the branch name). Thus, in order to use a persistent
      branch, you need to provide its name: see the <a href="Irmin.BC.html#VALof_branch_id">of_branch_id</a>
      function.<br>

<pre><span id="TYPEcommit_id"><span class="keyword">type</span> <code class="type"></code>commit_id</span> </pre>
<div class="info ">
Type for commit identifiers. Similar to Git's commit SHA1s.<br>
</div>


<pre><span id="TYPEbranch_id"><span class="keyword">type</span> <code class="type"></code>branch_id</span> </pre>
<div class="info ">
Type for persistent branch names. Branches usually share a common
      global namespace and it's the user's responsibility to avoid
      name clashes.<br>
</div>


<pre><span id="TYPEslice"><span class="keyword">type</span> <code class="type"></code>slice</span> </pre>
<div class="info ">
Type for store slices.<br>
</div>


<pre><span class="keyword">module</span> <a href="Irmin.BC.Repo.html">Repo</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Irmin.BC.Repo.html">..</a> <code class="code"><span class="keyword">end</span></code></pre>
<pre><span class="keyword">include</span> <a href="Irmin.HRW.html">Irmin.HRW</a></pre>
<br>
A branch-consistent store is a hierarchical read-write store.<br>

<pre><span id="VALmaster"><span class="keyword">val</span> master</span> : <code class="type">'a <a href="Irmin.Task.html#TYPEf">Irmin.Task.f</a> -> <a href="Irmin.BC.Repo.html#TYPEt">Repo.t</a> -> ('a -> t) Lwt.t</code></pre><div class="info ">
<code class="code">master repo task</code> is a function returning fresh store
      handles within the repository <code class="code">repo</code>, with fresh tasks
      computed using <code class="code">task</code>.
      The result is a persistent branch using the  reference.
      This operation is cheap, can be repeated multiple times.<br>
</div>

<pre><span id="VALrepo"><span class="keyword">val</span> repo</span> : <code class="type">t -> <a href="Irmin.BC.Repo.html#TYPEt">Repo.t</a></code></pre><div class="info ">
<code class="code">repo t</code> is the repository containing <code class="code">t</code>.<br>
</div>

<pre><span id="VALtask"><span class="keyword">val</span> task</span> : <code class="type">t -> <a href="Irmin.html#TYPEtask">Irmin.task</a></code></pre><div class="info ">
<code class="code">task t</code> is the task associated to the store handle <code class="code">t</code>.<br>
</div>

<pre><span id="VALof_branch_id"><span class="keyword">val</span> of_branch_id</span> : <code class="type">'a <a href="Irmin.Task.html#TYPEf">Irmin.Task.f</a> -> <a href="Irmin.BC.html#TYPEbranch_id">branch_id</a> -> <a href="Irmin.BC.Repo.html#TYPEt">Repo.t</a> -> ('a -> t) Lwt.t</code></pre><div class="info ">
<code class="code">of_branch_id t name</code> is the persistent branch named <code class="code">name</code>. Similar to
      <code class="code">master</code>, but use <code class="code">name</code> instead <a href="Irmin.Ref.S.html#VALmaster"><code class="code"><span class="constructor">Irmin</span>.<span class="constructor">Ref</span>.<span class="constructor">S</span>.master</code></a>.<br>
</div>

<pre><span id="VALname"><span class="keyword">val</span> name</span> : <code class="type">t -> <a href="Irmin.BC.html#TYPEbranch_id">branch_id</a> option Lwt.t</code></pre><div class="info ">
<code class="code">name t</code> is <code class="code">t</code>'s branch name. Return <code class="code"><span class="constructor">None</span></code> if <code class="code">t</code> is not persistent.<br>
</div>

<pre><span id="VALname_exn"><span class="keyword">val</span> name_exn</span> : <code class="type">t -> <a href="Irmin.BC.html#TYPEbranch_id">branch_id</a> Lwt.t</code></pre><div class="info ">
Same as <a href="Irmin.BC.html#VALname"><code class="code"><span class="constructor">Irmin</span>.<span class="constructor">BC</span>.name</code></a> but raise <code class="code"><span class="constructor">Invalid_argument</span></code> if <code class="code">t</code> is not
      persistent.<br>
</div>

<pre><span id="VALupdate_branch"><span class="keyword">val</span> update_branch</span> : <code class="type">t -> <a href="Irmin.BC.html#TYPEbranch_id">branch_id</a> -> unit Lwt.t</code></pre><div class="info ">
<code class="code">update_branch t src</code> updates <code class="code">t</code>'s contents with the contents of
      the branch named <code class="code">src</code>. Can cause data losses as it discard the
      current contents. Similar to <code class="code">git reset --hard &lt;src&gt;</code>.<br>
</div>

<pre><span id="VALmerge_branch"><span class="keyword">val</span> merge_branch</span> : <code class="type">t -><br>       ?max_depth:int -><br>       ?n:int -> <a href="Irmin.BC.html#TYPEbranch_id">branch_id</a> -> unit <a href="Irmin.Merge.html#TYPEresult">Irmin.Merge.result</a> Lwt.t</code></pre><div class="info ">
<code class="code">merge_branch t other</code> merges the contents of the branch named <code class="code">other</code>
      into <code class="code">t</code>. Similar to <code class="code">git merge &lt;other&gt;</code>.<br>
</div>

<pre><span id="VALmerge_branch_exn"><span class="keyword">val</span> merge_branch_exn</span> : <code class="type">t -> ?max_depth:int -> ?n:int -> <a href="Irmin.BC.html#TYPEbranch_id">branch_id</a> -> unit Lwt.t</code></pre><div class="info ">
Same as <a href="Irmin.BC.html#VALmerge_branch"><code class="code"><span class="constructor">Irmin</span>.<span class="constructor">BC</span>.merge_branch</code></a> but raise <a href="Irmin.Merge.html#EXCEPTIONConflict"><code class="code"><span class="constructor">Irmin</span>.<span class="constructor">Merge</span>.<span class="constructor">Conflict</span></code></a> in case of
      conflict.<br>
</div>
<br>
<h2 id="temporary">Temporary Stores</h2>
<p>

      Temporary stores do not have stable names: instead they can be
      addressed using the hash of the current commit. These hashes are
      called <a href="Irmin.BC.html#VALhead">heads</a> in Irmin. Temporary stores are
      similar to Git's detached heads. In a temporary store, all the
      operations are performed relative to the current head and update
      operations can modify the current head: the current stores's
      head will automatically become the new head obtained while
      performing the update.
<p>

      Temporary stores are created using the <code class="code"><span class="constructor">BC</span>.of_head</code>
      function.<br>

<pre><span id="VALempty"><span class="keyword">val</span> empty</span> : <code class="type">'a <a href="Irmin.Task.html#TYPEf">Irmin.Task.f</a> -> <a href="Irmin.BC.Repo.html#TYPEt">Repo.t</a> -> ('a -> t) Lwt.t</code></pre><div class="info ">
<code class="code">empty repo task</code> is a temporary, empty store. Becomes a
      normal temporary store after the first update.<br>
</div>

<pre><span id="VALof_commit_id"><span class="keyword">val</span> of_commit_id</span> : <code class="type">'a <a href="Irmin.Task.html#TYPEf">Irmin.Task.f</a> -> <a href="Irmin.BC.html#TYPEcommit_id">commit_id</a> -> <a href="Irmin.BC.Repo.html#TYPEt">Repo.t</a> -> ('a -> t) Lwt.t</code></pre><div class="info ">
Create a temporary store, using the given <code class="code">commit_id</code>. The store
      will not persist as it has no persistent branch name.<br>
</div>

<pre><span id="VALhead"><span class="keyword">val</span> head</span> : <code class="type">t -> <a href="Irmin.BC.html#TYPEcommit_id">commit_id</a> option Lwt.t</code></pre><div class="info ">
<code class="code">head t</code> is the current head of the store <code class="code">t</code>. This works for
      both persistent and temporary stores. In the case of a
      persistent branch, this involves getting the the head associated
      with the branch's ID, so this may block. In the case of a
      temporary store, it simply returns the current head. Returns
      <code class="code"><span class="constructor">None</span></code> if the store has no contents. Similar to <code class="code">git
      rev-parse <span class="constructor">HEAD</span></code>.<br>
</div>

<pre><span id="VALhead_exn"><span class="keyword">val</span> head_exn</span> : <code class="type">t -> <a href="Irmin.BC.html#TYPEcommit_id">commit_id</a> Lwt.t</code></pre><div class="info ">
Same as <a href="Irmin.BC.html#VALhead"><code class="code"><span class="constructor">Irmin</span>.<span class="constructor">BC</span>.head</code></a> but raise <code class="code"><span class="constructor">Invalid_argument</span></code> if the store does
      not have any contents.<br>
</div>

<pre><span id="VALhead_ref"><span class="keyword">val</span> head_ref</span> : <code class="type">t -> [ `Branch of <a href="Irmin.BC.html#TYPEbranch_id">branch_id</a> | `Empty | `Head of <a href="Irmin.BC.html#TYPEcommit_id">commit_id</a> ]</code></pre><div class="info ">
<code class="code">head_ref t</code> is the branch ID that this store tracks (for persistent
      stores), the current <code class="code">head</code> commit (for temporary stores), or <code class="code"><span class="keywordsign">`</span><span class="constructor">Empty</span></code>
      for empty temporary stores.<br>
</div>

<pre><span id="VALupdate_head"><span class="keyword">val</span> update_head</span> : <code class="type">t -> <a href="Irmin.BC.html#TYPEcommit_id">commit_id</a> -> unit Lwt.t</code></pre><div class="info ">
<code class="code">update_head t h</code> updates <code class="code">t</code>'s contents with the contents of
      the commit_id <code class="code">h</code>. Can cause data loss as it discards the current
      contents. Similar to <code class="code">git reset --hard &lt;hash&gt;</code>.<br>
</div>

<pre><span id="VALfast_forward_head"><span class="keyword">val</span> fast_forward_head</span> : <code class="type">t -> ?max_depth:int -> ?n:int -> <a href="Irmin.BC.html#TYPEcommit_id">commit_id</a> -> bool Lwt.t</code></pre><div class="info ">
<code class="code">fast_forward_head t h</code> is similar to <a href="Irmin.BC.html#VALupdate_head"><code class="code"><span class="constructor">Irmin</span>.<span class="constructor">BC</span>.update_head</code></a> but the
      <code class="code">t</code>'s head is updated to <code class="code">h</code> only if <code class="code">h</code> is stricly in the
      future of <code class="code">t</code>'s current head. Return <code class="code"><span class="keyword">false</span></code> if it is not the
      case. If present, <code class="code">max_depth</code> or <code class="code">n</code> are used to limit the
      search space of the lowest common ancestors (see <a href="Irmin.BC.html#VALlcas"><code class="code"><span class="constructor">Irmin</span>.<span class="constructor">BC</span>.lcas</code></a>).<br>
</div>

<pre><span id="VALcompare_and_set_head"><span class="keyword">val</span> compare_and_set_head</span> : <code class="type">t -><br>       test:<a href="Irmin.BC.html#TYPEcommit_id">commit_id</a> option -> set:<a href="Irmin.BC.html#TYPEcommit_id">commit_id</a> option -> bool Lwt.t</code></pre><div class="info ">
Same as <a href="Irmin.BC.html#VALupdate_head"><code class="code"><span class="constructor">Irmin</span>.<span class="constructor">BC</span>.update_head</code></a> but check that the value is <code class="code">test</code> before
      updating to <code class="code">set</code>. Use <code class="code">update</code> or <a href="Irmin.BC.html#VALmerge"><code class="code"><span class="constructor">Irmin</span>.<span class="constructor">BC</span>.merge</code></a> instead if
      possible.<br>
</div>

<pre><span id="VALmerge_head"><span class="keyword">val</span> merge_head</span> : <code class="type">t -><br>       ?max_depth:int -><br>       ?n:int -> <a href="Irmin.BC.html#TYPEcommit_id">commit_id</a> -> unit <a href="Irmin.Merge.html#TYPEresult">Irmin.Merge.result</a> Lwt.t</code></pre><div class="info ">
<code class="code">merge_head t ?max_head ?n commit_id</code> merges the contents of the
      commit associated to <code class="code">commit_id</code> into <code class="code">t</code>. <code class="code">max_depth</code> is
      the maximal depth used for getting the lowest common
      ancestor. <code class="code">n</code> is the maximum number of lowest common
      ancestors. If present, <code class="code">max_depth</code> or <code class="code">n</code> are used to limit the
      search space of the lowest common ancestors (see <a href="Irmin.BC.html#VALlcas"><code class="code"><span class="constructor">Irmin</span>.<span class="constructor">BC</span>.lcas</code></a>).<br>
</div>

<pre><span id="VALmerge_head_exn"><span class="keyword">val</span> merge_head_exn</span> : <code class="type">t -> ?max_depth:int -> ?n:int -> <a href="Irmin.BC.html#TYPEcommit_id">commit_id</a> -> unit Lwt.t</code></pre><div class="info ">
Same as <a href="Irmin.BC.html#VALmerge_head">merge_head</a> but raise <a href="Irmin.Merge.html#EXCEPTIONConflict"><code class="code"><span class="constructor">Irmin</span>.<span class="constructor">Merge</span>.<span class="constructor">Conflict</span></code></a>
      in case of a conflict.<br>
</div>

<pre><span id="VALwatch_head"><span class="keyword">val</span> watch_head</span> : <code class="type">t -><br>       ?init:<a href="Irmin.BC.html#TYPEcommit_id">commit_id</a> -><br>       (<a href="Irmin.BC.html#TYPEcommit_id">commit_id</a> <a href="Irmin.html#TYPEdiff">Irmin.diff</a> -> unit Lwt.t) -> (unit -> unit Lwt.t) Lwt.t</code></pre><div class="info ">
<code class="code">watch_branch t f</code> calls <code class="code">f</code> every time the contents of <code class="code">t</code>'s reference
      is updated. Do nothing if <code class="code">t</code> is not persistent. Return a clean-up
      function to remove the watch handler.
<p>

      <b>Note:</b> even <code class="code">f</code> might skip some head updates, it will never
      be called concurrently: all consecutive calls to <code class="code">f</code> are done in
      sequence, so we ensure that the previous one ended before
      calling the next one.<br>
</div>

<pre><span id="VALwatch_key"><span class="keyword">val</span> watch_key</span> : <code class="type">t -><br>       key -><br>       ?init:<a href="Irmin.BC.html#TYPEcommit_id">commit_id</a> * value -><br>       ((<a href="Irmin.BC.html#TYPEcommit_id">commit_id</a> * value) <a href="Irmin.html#TYPEdiff">Irmin.diff</a> -> unit Lwt.t) -><br>       (unit -> unit Lwt.t) Lwt.t</code></pre><div class="info ">
<code class="code">watch_key t key f</code> calls <code class="code">f</code> every time the <code class="code">key</code>'s value is
      added, removed or updated. If the current branch is deleted, no
      signal is sent to the watcher.<br>
</div>
<br>
<h2 id="2_ClonesandMerges">Clones and Merges</h2><br>

<pre><span id="VALclone"><span class="keyword">val</span> clone</span> : <code class="type">'a <a href="Irmin.Task.html#TYPEf">Irmin.Task.f</a> -><br>       t -><br>       <a href="Irmin.BC.html#TYPEbranch_id">branch_id</a> -><br>       [ `Duplicated_branch | `Empty_head | `Ok of 'a -> t ] Lwt.t</code></pre><div class="info ">
Clone the store <code class="code">t</code>, using the given branch name. Return
      <code class="code"><span class="constructor">Duplicated_branch</span></code> if a branch with the same name already exists
      and <code class="code"><span class="constructor">Empty_head</span></code> if <code class="code">t</code> has no head.<br>
</div>

<pre><span id="VALclone_force"><span class="keyword">val</span> clone_force</span> : <code class="type">'a <a href="Irmin.Task.html#TYPEf">Irmin.Task.f</a> -> t -> <a href="Irmin.BC.html#TYPEbranch_id">branch_id</a> -> ('a -> t) Lwt.t</code></pre><div class="info ">
Same as <a href="Irmin.BC.html#VALclone">clone</a> but delete and update the existing
      branch if a branch with the same name already exists.<br>
</div>

<pre><span id="VALmerge"><span class="keyword">val</span> merge</span> : <code class="type">'a -><br>       ?max_depth:int -><br>       ?n:int -> ('a -> t) -> into:('a -> t) -> unit <a href="Irmin.Merge.html#TYPEresult">Irmin.Merge.result</a> Lwt.t</code></pre><div class="info ">
<code class="code">merge x t i</code> merges <code class="code">t x</code>'s current branch into <code class="code">i x</code>'s current
      branch. After that operation, the two stores are still
      independent. Similar to <code class="code">git merge &lt;branch&gt;</code>.<br>
</div>

<pre><span id="VALmerge_exn"><span class="keyword">val</span> merge_exn</span> : <code class="type">'a -> ?max_depth:int -> ?n:int -> ('a -> t) -> into:('a -> t) -> unit Lwt.t</code></pre><div class="info ">
FIXME Same as <a href="Irmin.BC.html#VALmerge">merge</a> but raise <a href="Irmin.Merge.html#EXCEPTIONConflict"><code class="code"><span class="constructor">Irmin</span>.<span class="constructor">Merge</span>.<span class="constructor">Conflict</span></code></a> in case
      of a conflict.<br>
</div>

<pre><span id="VALlcas"><span class="keyword">val</span> lcas</span> : <code class="type">'a -><br>       ?max_depth:int -><br>       ?n:int -><br>       ('a -> t) -><br>       ('a -> t) -><br>       [ `Max_depth_reached | `Ok of <a href="Irmin.BC.html#TYPEcommit_id">commit_id</a> list | `Too_many_lcas ]<br>       Lwt.t</code></pre><div class="info ">
<code class="code">lca ?max_depth ?n msg t1 t2</code> returns the collection of least
      common ancestors between the heads of <code class="code">t1</code> and <code class="code">t2</code> branches.
<p>

      <ul>
<li><code class="code">max_depth</code> is the maximum depth of the exploration (default
      is <code class="code">max_int</code>). Return <code class="code"><span class="keywordsign">`</span><span class="constructor">Max_depth_reached</span></code> if this depth is
      exceeded.</li>
<li><code class="code">n</code> is the maximum expected number of lcas. Stop the
      exploration as soon as <code class="code">n</code> lcas are found. Return
      <code class="code"><span class="keywordsign">`</span><span class="constructor">Too_many_lcas</span></code> if more <code class="code">lcas</code> are found. </li>
</ul>
<br>
</div>

<pre><span id="VALlcas_branch"><span class="keyword">val</span> lcas_branch</span> : <code class="type">t -><br>       ?max_depth:int -><br>       ?n:int -><br>       <a href="Irmin.BC.html#TYPEbranch_id">branch_id</a> -><br>       [ `Max_depth_reached | `Ok of <a href="Irmin.BC.html#TYPEcommit_id">commit_id</a> list | `Too_many_lcas ]<br>       Lwt.t</code></pre><div class="info ">
Same as <a href="Irmin.BC.html#VALlcas"><code class="code"><span class="constructor">Irmin</span>.<span class="constructor">BC</span>.lcas</code></a> but takes a branch ID as argument.<br>
</div>

<pre><span id="VALlcas_head"><span class="keyword">val</span> lcas_head</span> : <code class="type">t -><br>       ?max_depth:int -><br>       ?n:int -><br>       <a href="Irmin.BC.html#TYPEcommit_id">commit_id</a> -><br>       [ `Max_depth_reached | `Ok of <a href="Irmin.BC.html#TYPEcommit_id">commit_id</a> list | `Too_many_lcas ]<br>       Lwt.t</code></pre><div class="info ">
Same as <a href="Irmin.BC.html#VALlcas"><code class="code"><span class="constructor">Irmin</span>.<span class="constructor">BC</span>.lcas</code></a> but takes a commit_id as argument.<br>
</div>
<br>
<h2 id="2_History">History</h2><br>

<pre><span class="keyword">module</span> <a href="Irmin.BC.History.html">History</a>: <code class="type">Graph.Sig.P</code><code class="type">  with type V.t = commit_id</code></pre><div class="info">
An history is a DAG of heads.
</div>

<pre><span id="VALhistory"><span class="keyword">val</span> history</span> : <code class="type">?depth:int -><br>       ?min:<a href="Irmin.BC.html#TYPEcommit_id">commit_id</a> list -><br>       ?max:<a href="Irmin.BC.html#TYPEcommit_id">commit_id</a> list -> t -> History.t Lwt.t</code></pre><div class="info ">
<code class="code">history ?depth ?min ?max t</code> is a view of the history of the
      store <code class="code">t</code>, of depth at most <code class="code">depth</code>, starting from the <code class="code">max</code>
      (or from the <code class="code">t</code>'s head if the list of heads is empty) and
      stopping at <code class="code">min</code> if specified.<br>
</div>
</body></html>